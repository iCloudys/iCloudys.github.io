<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[runtime能做些什么]]></title>
    <url>%2F2018%2Fruntime%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言面试的时候面试官问：讲讲对runtime的理解，runtime能做些什么? 我基本上就是回答动态添加属性、添加方法、方法的替换……等网络罗列的一大堆。但是具体怎么做，这个嘛，我也说不出来。基于此，我特地研究了一下runtime.h这个文件，过滤了一下里面所有的方法并且了解基本功能并记录在此。 准备进入到runtime.h文件里面，发现里面有些方法标记的是OBJC_ARC_UNAVAILABLE，所以我们需要单独创建一个MRC项目，以便于尝试所有方法。 创建项目这里我们创建Command Line Tool工程即可，如图一: MRC项目创建完成后，默认是ARC模式的，这里我们修改为MRC。在TATGET-&gt; Build Settings-&gt;Objective-C Automatic Reference Counting-&gt;NO,默认为YES表示使用ARC模式，这里我们修改为NO即可。 类创建我们的测试类，创建Animal类，添加一个name属性和一个speak方法,一起看下类的构造: 方法介绍准备好了之后，来到main.m文件,导入objc/runtime.h和Animal.h头文件文件。 实例方法object_copy原型: 123OBJC_EXPORT id _Nullable object_copy(id _Nullable obj, size_t size)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:拷贝对象用的,和copy方法一样,返回一个新的对象。参数:obj被拷贝的对象，size对象的占用内存大小，从源码可知，size最小为16。注意:这个方法是OBJC_ARC_UNAVAILABLE，在ARC下不可用,而且如果参数obj为nil 或者是TaggedPointer,则直接返回obj,并不进行拷贝。 object_dispose原型: 123OBJC_EXPORT id _Nullable object_dispose(id _Nullable obj)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:销毁对象，并且释放空间。参数:obj要释放的对象。注意:在demo中,调用此方法后，对象还是能正常使用，没有查找到原因，改天研究下单列一篇文章。源码: 1234567id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 从源码中可以看到，首先判断obj是否为空，否则调用objc_destructInstance销毁对象,然后调用free()释放空间。 object_getClass原型: 123OBJC_EXPORT Class _Nullableobject_getClass(id _Nullable obj) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取对象的Class，和对象直接调用class方法基本一致,内部实现是返回obj的isa指针，对于isa指针这里不赘述。注意:如果obj传nil,则返回值为Nil object_setClass原型: 123OBJC_EXPORT Class _Nullableobject_setClass(id _Nullable obj, Class _Nonnull cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 修改一个对象的类,目的是修改一个对象的isa指针,返回值是旧的class。注意:调用此方法之后，对象的类型就会改变，所以在开发中应该谨慎使用此方法。由下图中可以看到，调用object_setClass方法后，a1由原来的Animal 变成NSObject对象，然后在向a发送消息立即崩溃。崩溃信息提示NSObject不存在setName方法。 object_isClass原型: 123OBJC_EXPORT BOOLobject_isClass(id _Nullable obj) OBJC_AVAILABLE(10.10, 8.0, 9.0, 1.0, 2.0); 描述:判断一个对象是否是类对象，注意:类也是一个对象，具体为什么，这里不会赘述。由下图可以看出，a1不是一个类，所以他不是类对象，Animal是一个类，所以返回TRUE。 object_getIvar原型: 123OBJC_EXPORT id _Nullableobject_getIvar(id _Nullable obj, Ivar _Nonnull ivar) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 获取obj的ivar的值。和这个方法功能类似的还有一个方法object_setInstanceVariable,但是这个获取的结果速度回更快一些，从object_setInstanceVariable源码中可以看出来，最终也是调用的这个方法。为了测试此方法，我们为Animal类添加一个变量age。由下图也可以看出属性和变量的区别。 object_getInstanceVariable原型: 12345OBJC_EXPORT Ivar _Nullableobject_getInstanceVariable(id _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:这个方法和上个方法类似，也是获取属性或者变量的值，只不过参数和返回值不同。参数:obj被获取的对象;name变量的名称,字符串格式;outValue这个变量的值。通过源码可以看出这个方法的实现过程就是通过name获取Ivar,然后调用上述方法。所以官方注释上说此方法慢与上述方法。这里就不上图了，图和👆的一样。 object_setIvarobject_setIvarWithStrongDefault原型: 123OBJC_EXPORT voidobject_setIvar(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 1234OBJC_EXPORT voidobject_setIvarWithStrongDefault(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value) OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0); 描述:因为这两个方法基本相同,所以这里放在一块说了，这两个方法是给变量赋值，相当于a1.name=我是小狗。这两个方法的区别在于第一个会给属性用Unretained修饰，第二个会用Strong修饰，注意这个前提是这个属性没有被修饰的情况下才会起作用。比如name已经被copy修饰了，那就保持原来的样子，那么这两个方法是没有区别的。参数:obj被赋值的对象;Ivar即将赋值的变量,value被赋的值。注意:如果对象没有这个属性，是不能赋值的。 object_setInstanceVariableobject_setInstanceVariableWithStrongDefault原型: 12345OBJC_EXPORT Ivar _Nullableobject_setInstanceVariable(id _Nullable obj, const char * _Nonnull name, void * _Nullable value)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 123456OBJC_EXPORT Ivar _Nullableobject_setInstanceVariableWithStrongDefault(id _Nullable obj, const char * _Nonnull name, void * _Nullable value)OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:这两个方法和上面两个方法基本相同,只是参数和返回值不同，从源码可以看出内部调用的也是上述两个方法而已。直接演示使用方法： 获得类定义objc_getClassobjc_lookUpClass原型: 123OBJC_EXPORT Class _Nullableobjc_getClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 123OBJC_EXPORT Class _Nullableobjc_lookUpClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:上面两个方法都是通过字符串获取一个Class,并且整个类是在工程里面存在的，否则会返回nil。注释上说objc_getClass方法会在第一次没有找到Class的情况下会再次查询一变并且执行回调。从源码上面看着两个方法都是执行了look_up_class(const char *aClassName, bool includeUnconnected, bool includeClassHandler)这个方法。区别在于includeClassHandler这个参数。objc_getClass传的是YES，而后者是NO。在look_up_class实现上看，旧版本的实现是按照注释上所说的一样。但是新版本的这个参数被标记为unused,基本上现在两个方法相同。 objc_getRequiredClass原型: 123OBJC_EXPORT Class _Nonnullobjc_getRequiredClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:这个方法和上面的objc_getClass方法基本一致，内部调用的就是objc_getClass这个方法，只不过在没有找到方法的情况下，会报链接失败。贴下源码: 123456Class objc_getRequiredClass(const char *aClassName)&#123; Class cls = objc_getClass(aClassName); if (!cls) _objc_fatal(&quot;link error: class &apos;%s&apos; not found.&quot;, aClassName); return cls;&#125; objc_getMetaClass原型: 123OBJC_EXPORT Class _Nonnullobjc_getMetaClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:获取类的元类,这个方法和objc_getRequiredClass基本类似，也是调用了objc_getClass这个方法，只不过在没有找到Class的时候会报提示信息，不会Crash,然后会返回Nil,最终返回Class的isa指针。从图中看到控制台里面打印信息。贴下源码: 123456789101112131415Class objc_getMetaClass(const char *aClassName)&#123; Class cls; if (!aClassName) return Nil; cls = objc_getClass (aClassName); if (!cls) &#123; _objc_inform (&quot;class `%s&apos; not linked into application&quot;, aClassName); return Nil; &#125; return cls-&gt;ISA();&#125; objc_getClassList原型: 123OBJC_EXPORT int objc_getClassList(Class _Nonnull * _Nullable buffer, int bufferCount)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:获取指定的个数类列表。buffer需要传入一个Class数组，bufferCount需要传入想要的个数,返回值是类的总数。如果bufferCount传入的数比类的总数大，则最多能返回所有的类。如果bufferCount比类的总数小，则会返回这个个数的类，从下图中可以看到已经有13062个类了。注意:获取的类有可能不是NSObject的子类，所以要小心调用这些类的方法.图中实例获取10个类: objc_copyClassList原型: 123OBJC_EXPORT Class _Nonnull * _Nullableobjc_copyClassList(unsigned int * _Nullable outCount)OBJC_AVAILABLE(10.7, 3.1, 9.0, 1.0, 2.0); 描述:这个方法和上面的方法类似，只不过这个是一次性获取所有的类，outCount向外输出类的总个数。注意:这个方法返回值是Class指针，所以在使用完成后需要调用free()进行释放。 类方法class_getName原型: 123OBJC_EXPORT const char * _Nonnullclass_getName(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 获取Class的名字，返回值类型是const char *。这个在简单不过，上图已经演示了。不在赘述。 class_isMetaClass原型: 123OBJC_EXPORT BOOLclass_isMetaClass(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:判断一个Class是否是元类，返回值是bool类型。 class_getSuperclass原型: 123OBJC_EXPORT Class _Nullableclass_getSuperclass(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取Class的父类。 和OC的superclass功能一样。从下图可以看出Animal的父类是NSObject。 class_setSuperclass原型: 1234567OBJC_EXPORT Class _Nonnullclass_setSuperclass(Class _Nonnull cls, Class _Nonnull newSuper) __OSX_DEPRECATED(10.5, 10.5, &quot;not recommended&quot;) __IOS_DEPRECATED(2.0, 2.0, &quot;not recommended&quot;) __TVOS_DEPRECATED(9.0, 9.0, &quot;not recommended&quot;) __WATCHOS_DEPRECATED(1.0, 1.0, &quot;not recommended&quot;)__BRIDGEOS_DEPRECATED(2.0, 2.0, &quot;not recommended&quot;); 描述:改变某个Class的父类。一定要谨慎使用这个函数。被标记为not recommended。返回值是就的父类。看下图，当把Animal的父类改成NSString之后，把a1当做字符串操作，运行没有任何问题。但是当调用Animal原来的方法之后，就会报方法找不到。 class_getVersionclass_setVersion123OBJC_EXPORT intclass_getVersion(Class _Nullable cls)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 123OBJC_EXPORT voidclass_setVersion(Class _Nullable cls, int version)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:这两个方法比较简单，就放一块说了，其实就是设置和获取Class的版本。 直接上图: class_getInstanceSize原型: 123OBJC_EXPORT size_tclass_getInstanceSize(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取这个类所占用字节数。不详细讲了，网上都是讲解。 class_getInstanceVariableclass_getClassVariableclass_copyIvarListclass_getInstanceMethodclass_getClassMethodclass_getMethodImplementationclass_getMethodImplementation_stretclass_respondsToSelectorclass_copyMethodListclass_conformsToProtocolclass_copyProtocolListclass_getPropertyclass_copyPropertyListclass_getIvarLayoutclass_getWeakIvarLayoutclass_addMethodclass_replaceMethodclass_addIvarclass_addProtocolclass_addPropertyclass_replacePropertyclass_setIvarLayoutclass_setWeakIvarLayoutobjc_getFutureClass实例化类class_createInstanceobjc_constructInstanceobjc_destructInstance添加类objc_allocateClassPairobjc_registerClassPairobjc_duplicateClassobjc_disposeClassPair方法method_getNamemethod_getImplementationmethod_getTypeEncodingmethod_getNumberOfArgumentsmethod_copyReturnTypemethod_copyArgumentTypemethod_getReturnTypemethod_getArgumentTypemethod_getDescriptionmethod_setImplementationmethod_exchangeImplementations实例变量ivar_getNameivar_getTypeEncodingivar_getOffset属性property_getNameproperty_getAttributesproperty_copyAttributeListproperty_copyAttributeValue协议objc_getProtocolobjc_copyProtocolListprotocol_conformsToProtocolprotocol_isEqualprotocol_getNameprotocol_getMethodDescriptionprotocol_copyMethodDescriptionListprotocol_getPropertyprotocol_copyPropertyListprotocol_copyPropertyList2protocol_copyProtocolListobjc_allocateProtocolobjc_registerProtocolprotocol_addMethodDescriptionprotocol_addProtocolprotocol_addProperty库objc_copyImageNamesclass_getImageNameobjc_copyClassNamesForImage选择器sel_getNamesel_registerNamesel_isEqualobjc_enumerationMutationobjc_setEnumerationMutationHandlerobjc_setForwardHandlerimp_implementationWithBlockimp_getBlockimp_removeBlockobjc_loadWeakobjc_storeWeak添加变量objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects]]></content>
  </entry>
  <entry>
    <title><![CDATA[.net搭建WebSocket]]></title>
    <url>%2F2018%2Fnet%E6%90%AD%E5%BB%BAWebSocket%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[KSThumbImage(一)]]></title>
    <url>%2F2018%2FKSThumbImage%2F</url>
    <content type="text"><![CDATA[我们不研究SDWebImage的源码，自己来写一个的获取视频缩略图的网络框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（二）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上次写过爬虫的初篇，我们已经能爬到基本的数据了。但是一张网页的数据是有限的，从我们上次的程序来看，能抓到的图片才不过十来张。很显然不能满足我们的需求。 接下来，我们继续完善我们的项目，来满足这个需求吧。 必备工具 联接网络的Mac, 浏览器，推荐用Google Chrome, Xcode开发工具, 用Objective-C写一个简单的爬虫(一) 的源码 必备技能建议看完 用Objective-C写一个简单的爬虫(一) ,明白一些简单的知识,虽然我写的很烂,但也不至于看这篇文章的时候一头雾水。 本篇目标深度抓取更多的数据如图: 分析在上篇中，我们给定一个url抓取完图片之后直接就结束了，那么如何不让程序结束，而继续抓取别的ur呢？总不能给SpiderOption定义一个url数组,程序的输入是有限的,这种办法解决不了问题。聪明的你一定想到了，在爬虫爬取图片的时候，不也是可以爬到这个页面的跳转页面么，如果我们在把跳转页面的图片爬下来，甚至把跳转页面里面的跳转页面爬下来，这样一直往深层次的抓取数据，就不是源源不断的图片爬到手了么？😎下面我们就开始吧！！！ 编码准备首先我们改造一下Spider类，给Spider添加几个变量:1、_finashUrl 用来存放已经爬取过的url,防止重复抓取,导致重复循环。2、_session 用来进行获取html的网络请求;在第一篇中我们直接在方法里面定义了相同的变量,这里我们把它声明成变量,防止重复创建对象.3、_urlExpression 用来匹配url的正则表达式.4、_imgExpression 用来匹配img的正则表达式.5、fetchHtmlQueue 正则匹配的队列.6、operationQueue 网络请求的队列. 定义上面变量之后并且在init方法中初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface Spider()&lt;NSURLSessionDataDelegate&gt;@property (nonatomic, strong) NSOperationQueue* fetchHtmlQueue;@property (nonatomic, strong) NSOperationQueue* operationQueue;@end@implementation Spider&#123; //已经抓取的url NSMutableSet&lt;NSString*&gt;* _finashUrl; NSRegularExpression* _urlExpression; NSRegularExpression* _imgExpression; NSURLSession* _session;&#125;- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; _finashUrl = [NSMutableSet set]; _imgExpression = [NSRegularExpression regularExpressionWithPattern:option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; _urlExpression = [NSRegularExpression regularExpressionWithPattern:@"https?:.+?.html" options:NSRegularExpressionCaseInsensitive error:nil]; _operationQueue = [[NSOperationQueue alloc] init]; _operationQueue.maxConcurrentOperationCount = 3; _operationQueue.name = @"com.html.loadQueue"; _fetchHtmlQueue = [[NSOperationQueue alloc] init]; _fetchHtmlQueue.maxConcurrentOperationCount = 3; _fetchHtmlQueue.name = @"com.html.fetchQueue"; NSURLSessionConfiguration* configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; configuration.timeoutIntervalForRequest = 30; _session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:_fetchHtmlQueue]; &#125; return self;&#125; 改写方法由于我们用了多线程的技术，每次加载一个url都要放到队列去，所以我们需要修改一下loadUrl方法: 12345678910111213141516- (void)loadUrl:(NSURL*)url&#123; WeakSelf; @synchronized(self)&#123; [self-&gt;_operationQueue addOperationWithBlock:^&#123; StrongSelf; NSURLSessionDataTask* task = [sSelf-&gt;_session dataTaskWithURL:url]; [task resume]; &#125;]; &#125;&#125; 上一步请求成功之后，会调用session的代理方法，所有我们需要实现session的代理方法: 1234567891011121314151617181920212223242526272829303132///MARK:- NSURLSessionDataDelegate- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler&#123; NSURLSessionResponseDisposition disposition = NSURLSessionResponseCancel; NSInteger statusCode = 0; if ([response respondsToSelector:@selector(statusCode)])&#123; statusCode = [((NSHTTPURLResponse*)response) statusCode]; &#125; if (statusCode == 200) &#123; disposition = NSURLSessionResponseAllow; &#125; completionHandler(disposition);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; if (html &amp;&amp; html.length &gt; 0) &#123; [self fetchUrlWithHtml:html]; [self fetchImgWithHtml:html]; &#125;&#125; 我们在修改一下fetchImgWithHtml方法,匹配img也要放到队列里,匹配成功后回调即可: 12345678910- (void)fetchImgWithHtml:(NSString*)html&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_imgExpression]; sSelf.option.complete ? sSelf.option.complete(strings) : nil; &#125;];&#125; 同理我们修改fetchUrlWithHtml方法,并且把需要请求的url放到_finashUrl里面,在请求之前判断一下是否请求过即可: 123456789101112131415161718- (void)fetchUrlWithHtml:(NSString*)html&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_urlExpression]; for (NSString* string in strings) &#123; NSURL* url = [NSURL URLWithString:string]; if ([sSelf-&gt;_finashUrl containsObject:string]) &#123; continue; &#125; [sSelf-&gt;_finashUrl addObject:string]; [sSelf loadUrl:url]; &#125; &#125;];&#125; 最后附上fetchStringsWithHtml方法: 12345678910111213141516- (NSArray&lt;NSString*&gt;*)fetchStringsWithHtml:(NSString*)html expression:(NSRegularExpression*)expression&#123; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; return strings;&#125; 运行接下来运行一下程序，我们能看到程序不停的抓取图片，越来越多。 可视化为了更好的浏览我们获取的图片，我们需要在控制器里面用UICollectionView展现出来，直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (void)appendUrls:(NSArray&lt;NSString *&gt;*)urls&#123; if (urls.count &gt; 0) &#123; WeakSelf; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView performBatchUpdates:^&#123; NSMutableArray&lt;NSIndexPath*&gt;* idxs = [NSMutableArray array]; for (int i = 0; i &lt; urls.count; i ++) &#123; NSIndexPath* idx = [NSIndexPath indexPathForItem:weakSelf.urls.count + i inSection:0]; [idxs addObject:idx]; &#125; [weakSelf.urls addObjectsFromArray:urls]; [weakSelf.collectionView insertItemsAtIndexPaths:idxs]; &#125; completion: NULL]; &#125;); &#125;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; self.collectionView.frame = self.view.bounds;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return self.urls.count;&#125;- (__kindof UICollectionViewCell*)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; CollectionViewCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:CollectionViewCellID forIndexPath:indexPath]; cell.url = self.urls[indexPath.row]; return cell;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.5;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.01;&#125;- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123; return UIEdgeInsetsZero;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewFlowLayout* layout = (UICollectionViewFlowLayout*)collectionViewLayout; CGFloat w = (CGRectGetWidth(collectionView.frame) - layout.minimumInteritemSpacing - layout.sectionInset.left - layout.sectionInset.right) / 8 - 0.5; return CGSizeMake(w, w);&#125;- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; DetailController* detail = [[DetailController alloc] init]; detail.url = self.urls[indexPath.row]; [self.navigationController pushViewController:detail animated:YES];&#125;- (UICollectionView *)collectionView&#123; if (!_collectionView) &#123; UICollectionViewFlowLayout* layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumLineSpacing = 0.5; layout.minimumInteritemSpacing = 0; layout.sectionInset = UIEdgeInsetsZero; _collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:layout]; _collectionView.delegate = self; _collectionView.dataSource = self; [_collectionView registerClass:[CollectionViewCell class] forCellWithReuseIdentifier:CollectionViewCellID]; _collectionView.backgroundColor = [UIColor whiteColor]; &#125; return _collectionView;&#125; 至此，我们就算完成了我们的目标;看到程序不停的有图片加载出来，是不是有点小兴奋呢。😄现在我们写的程序会无限循环的爬取，但是怎么能控制爬取深度呢？ 控制深度我的做法是给url创建一个分类，添加一个属性depth表示此url的深度值,初始的url深度为0,在此页面上爬取的url深度为1，这样以此类推，直到我们指定深度停止为止。 NSURL+depth.h 12345@interface NSURL (depth)@property (nonatomic, assign) NSUInteger depth;@end NSURL+depth.m 1234567891011121314151617#import "NSURL+depth.h"#import &lt;objc/runtime.h&gt;static const void * depth_key = "depth_key";@implementation NSURL (depth)@dynamic depth;- (NSUInteger)depth&#123; return [objc_getAssociatedObject(self, depth_key) unsignedIntegerValue];&#125;- (void)setDepth:(NSUInteger)depth&#123; objc_setAssociatedObject(self, depth_key, @(depth), OBJC_ASSOCIATION_ASSIGN);&#125;@end 然后在我们的 start方法里面给第一个url的深度赋值: 123456- (void)start&#123; NSURL* url = [NSURL URLWithString:self.option.website]; url.depth = 0; [self loadUrl:url];&#125; 在session回调的方法里面我们判断一下此url的深度是否需要继续爬取: 12345678910111213- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSUInteger depth = dataTask.originalRequest.URL.depth; if (html &amp;&amp; html.length &gt; 0) &#123; if (depth &lt; self.option.maxDepth) &#123; [self fetchUrlWithHtml:html depth:depth + 1]; &#125; [self fetchImgWithHtml:html]; &#125;&#125; 然后改下fetchUrlWithHtml方法，给下个url赋值深度: 12345678910111213141516171819202122232425262728- (void)fetchUrlWithHtml:(NSString*)html depth:(NSUInteger)depth&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_urlExpression]; for (NSString* string in strings) &#123; NSURL* url = [NSURL URLWithString:string]; if ([sSelf-&gt;_finashUrl containsObject:string]) &#123; continue; &#125; url.depth = depth; [sSelf-&gt;_finashUrl addObject:string]; [sSelf loadUrl:url]; &#125; &#125;];&#125;``` 最后忘说了一个地方,那就是`SpiderOption`,给这个类添加一个最大深度的属性,让外界来控制: ```objc /** 最大抓取深度 默认 NSUIntegerMax */@property (nonatomic, assign) NSUInteger maxDepth; ok,在控制器里面给定最大的深度,最好不要太大,运行一下吧！！！ 相关链接: 项目源码 用Objective-C写一个简单的爬虫(一)]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（一）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[你是不是想写个爬虫来抓取点东西,但是你又不会Python或者别的语言，那么你就得感谢你自己能来到这里。接下来就交给你如何用Objective-C写一个爬虫。 什么？Objective-C也能写爬虫？不都是Python才可以的么？那么我告诉你基本上大部分语言都是可以写爬虫的，只是Python用来写爬虫比较方便，他有海量的三方库可以让开发者调用而已。而别的语言基本上就是靠自己苦逼的撸了。 那么用Objective-C写爬虫有什么用？靠iPhone来爬数据么？这里博主只是写个简单的爬虫而已，并不指望用此来专门抓取数据，你觉得让手机去爬数据能爬多少啊。本教程会兼容Mac软件开发，你可以用此技术开发mac爬虫工具。 废话少说，让我们来开始吧！ 必备工具 链接网络的Mac, 浏览器，推荐用Google Chrome Xcode开发工具 必备技能 熟悉Objective-C 能阅读HTML,能认识基本的标签即可 正则表达式,大概浏览一下就行,这里在遇到的时候博主会简单介绍一下 本篇目标 抓取回车桌面上的图片 附图: 分析网页用浏览器打开回车桌面,并且按下 option + command + i打开开发者工具。如图: 确保右上方是选中的Elements选项，下面HTML就是网页的源代码。鼠标在HTML上面移动的时候左侧页面会有相应的模块提示，我们以次点开标签，就能找到想要的图片地址: 如图: 粘一段代码: 123456&lt;img a_width="576" a_height="360" src="https://up.enterdesk.com/edpic_360_360/cf/e1/8f/cfe18f5a7e0a42355784bb992f313853.jpg" alt="清明节气" title="清明节气" style="height: 185px; width: 296px;"&gt; 上段代码中src就是网页中的图片地址，我们接下来就是把这个src的值提取出来。 编码上面我们分析了网页源码，接下来我们已经知道了大致流程： 获取网页源码 正则提取url 好! 让我们来创建一个Objective-C项目，这里我们主要是来介绍如何写爬虫，至于Objective-C项目自己创建即可。 初始化博主这里在主控制器上面添加一个UITextView，背景色为黑色；Tint 颜色为绿色，(这样的颜色看起来比较高大上一点)；不可编辑；打开超连接功能；并且连接到所在的控制器。如图: 创建工具类创建Spider类和SpiderOption类。Spider是爬虫工具类;SpiderOption是参数类，在爬数据过程中所需要的参数都由SpiderOption传递给Spider SpiderOption.h 12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;typedef void(^SpiderCompleteHander)(NSString* url);@interface SpiderOption : NSObject/** 目标网站 */@property (nonatomic, copy) NSString* website;/** 抓取数据正则表达式 */@property (nonatomic, copy) NSString* pattern;/** Url抓取完成回调 */@property (nonatomic, copy) SpiderCompleteHander progress;@end Spider.h 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;#import "SpiderOption.h"@interface Spider : NSObject/** 参数类 */@property (nonatomic, strong, readonly) SpiderOption* option;/** 初始化方法 @param option 参数类 @return self */- (instancetype)initWithOption:(SpiderOption*)option;/** 开始抓取 */- (void)start;@end Spider.m 1234567891011121314151617#import "Spider.h"@implementation Spider- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; &#125; return self;&#125;- (void)start&#123;&#125;@end 测试工具类经过第二步之后，初步的爬虫工具就可以使用了，下面我们在ViewController.m里面调用我们的爬虫工具。 ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142#import "ViewController.h"#import "Spider.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UITextView *textView;@property (strong, nonatomic) Spider *spider;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个参数类 SpiderOption* option = [[SpiderOption alloc] init]; //准备目标网址 option.website = @"https://www.enterdesk.com"; //处理回调，当成功抓取一个内容之后，我们就把他拼接到textView的底部 option.complete = ^(NSString *url) &#123; [self showLogs:url]; &#125;; //初始化爬虫类 self.spider = [[Spider alloc] initWithOption:option]; //开始抓取 [self.spider start];&#125;- (void)showLogs:(NSString*)log&#123; //把Log内容拼接到textView最下面，并且滚动到最下面 if (log.length &gt; 0) &#123; [self.textView insertText:[NSString stringWithFormat:@"%@\n\n",log]]; [self.textView scrollRangeToVisible:NSMakeRange(self.textView.text.length, 0)]; &#125;&#125;@end 现在来运行一下我们的项目，虽然不会报错，但是并没有开始爬什么数据，接下让我们来完善我们的Spider工具类。 完善工具类在我们的Spider.m里面添加一个方法，来获取网页的HTML源码： 12345678910111213141516171819- (void)loadUrl:(NSString*)urlString&#123; WeakSelf; urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL* url = [NSURL URLWithString:urlString]; NSURLSessionConfiguration* configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession* session = [NSURLSession sessionWithConfiguration:configuration]; NSURLSessionDataTask* task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@"%@",html); &#125; &#125;]; [task resume];&#125; 接下来在我们的start方法调用上述方法: 123- (void)start&#123; [self loadUrl:self.option.website];&#125; 让我们在运行一次项目，如果网络没有问题的话，我们就能看到控制器上面输出的HTML源码,尽管我们的textView还是黑黑的一片。如下图: 正则匹配我们再次给Spider.m添加一个方法,这个方法主要就是从HTML里面提取出我们想要的内容，比如我们的图片,然后回调给控制器: 123456789101112131415161718192021- (void)matchesStringInHtml:(NSString*)html&#123; WeakSelf; NSRegularExpression* expression = [NSRegularExpression regularExpressionWithPattern:self.option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; weakSelf.option.progress ? weakSelf.option.progress(strings) : nil;&#125; 方法写好了，我们需要在loadUrl的completionHandler调用一下. 123456789 ··· NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; if (!error &amp;&amp; html.length &gt; 0) &#123; [sSelf fetchImgWithHtml:html]; &#125;else&#123; NSLog(@"加载出错:%@",error); &#125; ··· 还需要给SpiderOption的pattern赋值，那我们在ViewController.m里面添加以下正则即可： 123456...option.website = @"https://www.enterdesk.com";option.pattern = @"(?&lt;=(src=\"))https?://.+?.(jpg|png)";... 最后，让我们运行以下看效果吧,是不是很简单呀！！！ 备注我们来解释一下正则(?&lt;=(src=\&quot;))https?://.+?.(jpg|png)表达式的含义: HTML中的图片地址可能类似于http://aaa.jpg、又或者是以https开头的https://aaa.jpg,那我们就用https?://aaa.jpg即可匹配http也可匹配https。?在这里表示前一个字符s有0个或者1个。 或许网页中的图片不仅仅是.jpg又或者是.png、.gif等等，我们用或|提取我们想要的格式图片。比如.(jpg|png)就是我们想取jpg或者是png的图片,如果你也想提取.gif的图片，可以这样写.(jpg|png|gif)即可。 我们再说说中间的.+?,.代表单个字符，比如正则表达式这样写http://..jpg我们只能提取http://a.jpg这中间只有单个字符的url。那如果我们想提取中间个数不确定的呢？比如http://abc.jpg?我们就在.后面加个+即可；+表示大于等于1个，比如http://.+.jpg我们既可以匹配到http://a.jpg也可匹配到http://aaa.jpg等中间多个字符的url。 那么后面的?呢,这里的?多代表的是非贪婪匹配，举个例子:http://aa.jpg.jpg像这种url我们该怎么提取呢，如果按照刚才http://.+.jpg的表达式匹配出来的是http://aa.jpg.jpg整个串，但是我们只想提取到http://aa.jpg怎么办，我们就在+后面加个?代表尽可能少的匹配，就是所谓的非贪婪匹配。 最后在说一下(?&lt;=(src=\&quot;))这个意思就是我们要提取src=&quot;后面的http:xx.jpg的图片，但是不包含src=&quot;。举个🌰:如果把这个表达式去掉，我们会发现提取到的url有可能是这样https://www.enterdesk.com/bizhi/5488.html\&quot;&gt;&lt;img src=\&quot;https://up.enterdesk.com/edpic_360_360/34/3f/f4/343ff4ada1548da0a81388f86dd9d1af.jpg，很显然这不是我们想要的结果。所以说这个就是起到了相应的作用。 相关链接: 项目源码 用Objective-C写一个简单的爬虫(二)]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[春江花月夜 【作者】张若虚 【朝代】唐 译文对照 春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰；空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。不知乘月几人归，落月摇情满江树。 12345@interface Dog- (void)viewDidLoad()&#123; NSLog(@"Hello world");&#125;@end 12345class Dog&#123; public static void main(String[] args)&#123; System.out.println("Hello world"); &#125;&#125; 仅此纪念部署的第一个博客， 特别感谢:Devin_ tag { color:#999999 } author { font-size:14px }]]></content>
  </entry>
</search>
