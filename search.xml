<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（二）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上次写过爬虫的初篇，我们已经能爬到基本的数据了。但是一张网页的数据是有限的，从我们上次的程序来看，能抓到的图片才不过十来张。很显然不能满足我们的需求。 接下来，我们继续完善我们的项目，来满足这个需求吧。 必备工具 联接网络的Mac, 浏览器，推荐用Google Chrome, Xcode开发工具, 用Objective-C写一个简单的爬虫(一) 的源码 必备技能建议看完 用Objective-C写一个简单的爬虫(一) ,明白一些简单的知识,虽然我写的很烂,但也不至于看这篇文章的时候一头雾水。 本篇目标深度抓取更多的数据如图: 分析在上篇中，我们给定一个url抓取完图片之后直接就结束了，那么如何不让程序结束，而继续抓取别的ur呢？总不能给SpiderOption定义一个url数组,程序的输入是有限的,这种办法解决不了问题。聪明的你一定想到了，在爬虫爬取图片的时候，不也是可以爬到这个页面的跳转页面么，如果我们在把跳转页面的图片爬下来，甚至把跳转页面里面的跳转页面爬下来，这样一直往深层次的抓取数据，就不是源源不断的图片爬到手了么？😎下面我们就开始吧！！！ 编码准备首先我们改造一下Spider类，在上次我们对单独的url抓取的的时候，在- (void)fetchImgWithHtml:(NSString*)html方法里创建了一个expression,这次我们需要把它声明成属性以防止给大量html匹配的时候重复创建对象而损耗性能。同时也要声明一个匹配深层次url的expression。 给Spider添加这两个变量和存放url的变量，并且在init的时候初始化: 12345678910111213141516171819202122232425262728293031@implementation Spider&#123; //等待抓取的Url NSMutableOrderedSet&lt;NSString*&gt;* _sourceUrl; //已经抓取的url NSMutableOrderedSet&lt;NSString*&gt;* _finashUrl; NSRegularExpression* _urlExpression; NSRegularExpression* _imgExpression;&#125;- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; _sourceUrl = [NSMutableOrderedSet orderedSet]; _finashUrl = [NSMutableOrderedSet orderedSet]; _imgExpression = [NSRegularExpression regularExpressionWithPattern:option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; _urlExpression = [NSRegularExpression regularExpressionWithPattern:@"https?:.+?.html" options:NSRegularExpressionCaseInsensitive error:nil]; &#125; return self;&#125; _sourceUrl 这个属性我们用来存放在html里面提取的url,也就是将要抓取它的图片；_finashUrl 这个属性我们用来存放已经抓取完成的url,防止以后重复抓取；这两个属性是NSMutableOrderedSet的类型，既可以去重，也可以保证有序进行。 改写方法我们在添加一个和fetchImgWithHtml功能相同的方法，来提取本页面的跳转链接,我们就叫fetchUrlWithHtml吧,然后再稍微封装一下: 12345678910111213141516171819202122232425262728293031- (void)fetchImgWithHtml:(NSString*)html&#123; NSArray&lt;NSString*&gt;* strings = [self fetchStringsWithHtml:html expression:_imgExpression]; self.option.complete ? self.option.complete(strings) : nil;&#125;- (void)fetchUrlWithHtml:(NSString*)html&#123; NSArray&lt;NSString*&gt;* strings = [self fetchStringsWithHtml:html expression:_urlExpression]; [self-&gt;_sourceUrl addObjectsFromArray:strings];&#125;- (NSArray&lt;NSString*&gt;*)fetchStringsWithHtml:(NSString*)html expression:(NSRegularExpression*)expression&#123; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; return strings;&#125; 在上面的代码中可以看到：我们封装了一个fetchStringsWithHtml方法，参数是html和NSRegularExpression对象，返回值是NSArray&lt;NSString*&gt;*,所有我们在匹配url和图片的方法里面直接调用这个方法即可。 在fetchUrlWithHtml方法里面，我们获取到strings之后，把结果直接放在了_sourceUrl里面；在fetchImgWithHtml方法里面，我们获取到strings之后，直接回调。 运行方法定义好了，接下来我们在loadUrl的completionHandler里面，调用fetchUrlWithHtml，让程序匹配一下将要抓取的网页地址: 1234567if (!error &amp;&amp; html.length &gt; 0) &#123; [sSelf fetchImgWithHtml:html]; [sSelf fetchUrlWithHtml:html];&#125;else&#123; NSLog(@"加载出错:%@",error);&#125; 接下来运行一下程序，DEBUG一下，会发现除了网页中的几张图片之外，_sourceUrl里面还会有几十个url。我们还需要继续让程序不停的抓取_sourceUrl里面的网站。 持续运行在定义一个- (void)loadNext方法,让程序分析完一张网页之后，继续分析下一张网页。我们还需要在loadUrl的completionHandler里面，调用loadNext: 123456···&#125;else&#123; NSLog(@"加载出错:%@",error);&#125;[sSelf loadNext]; 完善loadNxt方法:1、获取_sourceUrl第一个url执行2;2、判断这个url是否在_finashUrl里面，如果不存在执行3，否则执行4;3、把url放进_finashUrl,并且_sourceUrl移除此url,执行5;4、如果存在，丢弃此url,并且_sourceUrl移除此url,执行1;5、抓取此url成功后，执行1; 代码如下: 12345678910111213141516- (void)loadNext&#123; //上个url结束之后，继续下一个(先进先出) NSString* url = self-&gt;_sourceUrl.firstObject; [self-&gt;_sourceUrl removeObject:url]; if ([self-&gt;_finashUrl containsObject:url]) &#123; NSLog(@"丢弃:%@",url); [self loadNext]; &#125;else&#123; [self-&gt;_finashUrl addObject:url]; [self loadUrl:url]; &#125;&#125; 然后我么运行一下程序，就会看到控制台源源不断的输出url。 可视化为了更好的浏览我们获取的图片，我们需要在控制器里面用UICollectionView展现出来，直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (void)appendUrls:(NSArray&lt;NSString *&gt;*)urls&#123; if (urls.count &gt; 0) &#123; WeakSelf; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView performBatchUpdates:^&#123; NSMutableArray&lt;NSIndexPath*&gt;* idxs = [NSMutableArray array]; for (int i = 0; i &lt; urls.count; i ++) &#123; NSIndexPath* idx = [NSIndexPath indexPathForItem:weakSelf.urls.count + i inSection:0]; [idxs addObject:idx]; &#125; [weakSelf.urls addObjectsFromArray:urls]; [weakSelf.collectionView insertItemsAtIndexPaths:idxs]; &#125; completion: NULL]; &#125;); &#125;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; self.collectionView.frame = self.view.bounds;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return self.urls.count;&#125;- (__kindof UICollectionViewCell*)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; CollectionViewCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:CollectionViewCellID forIndexPath:indexPath]; cell.url = self.urls[indexPath.row]; return cell;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.5;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.01;&#125;- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123; return UIEdgeInsetsZero;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewFlowLayout* layout = (UICollectionViewFlowLayout*)collectionViewLayout; CGFloat w = (CGRectGetWidth(collectionView.frame) - layout.minimumInteritemSpacing - layout.sectionInset.left - layout.sectionInset.right) / 8 - 0.5; return CGSizeMake(w, w);&#125;- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; DetailController* detail = [[DetailController alloc] init]; detail.url = self.urls[indexPath.row]; [self.navigationController pushViewController:detail animated:YES];&#125;- (UICollectionView *)collectionView&#123; if (!_collectionView) &#123; UICollectionViewFlowLayout* layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumLineSpacing = 0.5; layout.minimumInteritemSpacing = 0; layout.sectionInset = UIEdgeInsetsZero; _collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:layout]; _collectionView.delegate = self; _collectionView.dataSource = self; [_collectionView registerClass:[CollectionViewCell class] forCellWithReuseIdentifier:CollectionViewCellID]; _collectionView.backgroundColor = [UIColor whiteColor]; &#125; return _collectionView;&#125; 至此，我们就算完成了我们的目标;看到程序不停的有图片加载出来，是不是有点小兴奋呢。😄但是新的问题又出现了:1、如果某个url加载速度比较慢,程序就会一直等待其返回之后才能进行下一个url;2、程序一直这样无限的加载么,怎么样定义一个最大深度,防止爬虫无限循环下去;好了,本篇先到这吧,以上两个新问题我们在列一篇解决。 相关链接: 用Objective-C写一个简单的爬虫(一)]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（一）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[你是不是想写个爬虫来抓取点东西,但是你又不会Python或者别的语言，那么你就得感谢你自己能来到这里。接下来就交给你如何用Objective-C写一个爬虫。 什么？Objective-C也能写爬虫？不都是Python才可以的么？那么我告诉你基本上大部分语言都是可以写爬虫的，只是Python用来写爬虫比较方便，他有海量的三方库可以让开发者调用而已。而别的语言基本上就是靠自己苦逼的撸了。 那么用Objective-C写爬虫有什么用？靠iPhone来爬数据么？这里博主只是写个简单的爬虫而已，并不指望用此来专门抓取数据，你觉得让手机去爬数据能爬多少啊。本教程会兼容Mac软件开发，你可以用此技术开发mac爬虫工具。 废话少说，让我们来开始吧！ 必备工具 链接网络的Mac, 浏览器，推荐用Google Chrome Xcode开发工具 必备技能 熟悉Objective-C 能阅读HTML,能认识基本的标签即可 正则表达式,大概浏览一下就行,这里在遇到的时候博主会简单介绍一下 本篇目标 抓取回车桌面上的图片 附图: 分析网页用浏览器打开回车桌面,并且按下 option + command + i打开开发者工具。如图: 确保右上方是选中的Elements选项，下面HTML就是网页的源代码。鼠标在HTML上面移动的时候左侧页面会有相应的模块提示，我们以次点开标签，就能找到想要的图片地址: 如图: 粘一段代码: 123456&lt;img a_width="576" a_height="360" src="https://up.enterdesk.com/edpic_360_360/cf/e1/8f/cfe18f5a7e0a42355784bb992f313853.jpg" alt="清明节气" title="清明节气" style="height: 185px; width: 296px;"&gt; 上段代码中src就是网页中的图片地址，我们接下来就是把这个src的值提取出来。 编码上面我们分析了网页源码，接下来我们已经知道了大致流程： 获取网页源码 正则提取url 好! 让我们来创建一个Objective-C项目，这里我们主要是来介绍如何写爬虫，至于Objective-C项目自己创建即可。 初始化博主这里在主控制器上面添加一个UITextView，背景色为黑色；Tint 颜色为绿色，(这样的颜色看起来比较高大上一点)；不可编辑；打开超连接功能；并且连接到所在的控制器。如图: 创建工具类创建Spider类和SpiderOption类。Spider是爬虫工具类;SpiderOption是参数类，在爬数据过程中所需要的参数都由SpiderOption传递给Spider SpiderOption.h 12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;typedef void(^SpiderCompleteHander)(NSString* url);@interface SpiderOption : NSObject/** 目标网站 */@property (nonatomic, copy) NSString* website;/** 抓取数据正则表达式 */@property (nonatomic, copy) NSString* pattern;/** Url抓取完成回调 */@property (nonatomic, copy) SpiderCompleteHander progress;@end Spider.h 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;#import "SpiderOption.h"@interface Spider : NSObject/** 参数类 */@property (nonatomic, strong, readonly) SpiderOption* option;/** 初始化方法 @param option 参数类 @return self */- (instancetype)initWithOption:(SpiderOption*)option;/** 开始抓取 */- (void)start;@end Spider.m 1234567891011121314151617#import "Spider.h"@implementation Spider- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; &#125; return self;&#125;- (void)start&#123;&#125;@end 测试工具类经过第二步之后，初步的爬虫工具就可以使用了，下面我们在ViewController.m里面调用我们的爬虫工具。 ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142#import "ViewController.h"#import "Spider.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UITextView *textView;@property (strong, nonatomic) Spider *spider;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个参数类 SpiderOption* option = [[SpiderOption alloc] init]; //准备目标网址 option.website = @"https://www.enterdesk.com"; //处理回调，当成功抓取一个内容之后，我们就把他拼接到textView的底部 option.complete = ^(NSString *url) &#123; [self showLogs:url]; &#125;; //初始化爬虫类 self.spider = [[Spider alloc] initWithOption:option]; //开始抓取 [self.spider start];&#125;- (void)showLogs:(NSString*)log&#123; //把Log内容拼接到textView最下面，并且滚动到最下面 if (log.length &gt; 0) &#123; [self.textView insertText:[NSString stringWithFormat:@"%@\n\n",log]]; [self.textView scrollRangeToVisible:NSMakeRange(self.textView.text.length, 0)]; &#125;&#125;@end 现在来运行一下我们的项目，虽然不会报错，但是并没有开始爬什么数据，接下让我们来完善我们的Spider工具类。 完善工具类在我们的Spider.m里面添加一个方法，来获取网页的HTML源码： 12345678910111213141516171819- (void)loadUrl:(NSString*)urlString&#123; WeakSelf; urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL* url = [NSURL URLWithString:urlString]; NSURLSessionConfiguration* configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession* session = [NSURLSession sessionWithConfiguration:configuration]; NSURLSessionDataTask* task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@"%@",html); &#125; &#125;]; [task resume];&#125; 接下来在我们的start方法调用上述方法: 123- (void)start&#123; [self loadUrl:self.option.website];&#125; 让我们在运行一次项目，如果网络没有问题的话，我们就能看到控制器上面输出的HTML源码,尽管我们的textView还是黑黑的一片。如下图: 正则匹配我们再次给Spider.m添加一个方法,这个方法主要就是从HTML里面提取出我们想要的内容，比如我们的图片,然后回调给控制器: 123456789101112131415161718192021- (void)matchesStringInHtml:(NSString*)html&#123; WeakSelf; NSRegularExpression* expression = [NSRegularExpression regularExpressionWithPattern:self.option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; weakSelf.option.progress ? weakSelf.option.progress(strings) : nil;&#125; 方法写好了，我们需要在loadUrl的completionHandler调用一下. 123456789 ··· NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; if (!error &amp;&amp; html.length &gt; 0) &#123; [sSelf fetchImgWithHtml:html]; &#125;else&#123; NSLog(@"加载出错:%@",error); &#125; ··· 还需要给SpiderOption的pattern赋值，那我们在ViewController.m里面添加以下正则即可： 123456...option.website = @"https://www.enterdesk.com";option.pattern = @"(?&lt;=(src=\"))https?://.+?.(jpg|png)";... 最后，让我们运行以下看效果吧,是不是很简单呀！！！ 备注我们来解释一下正则(?&lt;=(src=\&quot;))https?://.+?.(jpg|png)表达式的含义: HTML中的图片地址可能类似于http://aaa.jpg、又或者是以https开头的https://aaa.jpg,那我们就用https?://aaa.jpg即可匹配http也可匹配https。?在这里表示前一个字符s有0个或者1个。 或许网页中的图片不仅仅是.jpg又或者是.png、.gif等等，我们用或|提取我们想要的格式图片。比如.(jpg|png)就是我们想取jpg或者是png的图片,如果你也想提取.gif的图片，可以这样写.(jpg|png|gif)即可。 我们再说说中间的.+?,.代表单个字符，比如正则表达式这样写http://..jpg我们只能提取http://a.jpg这中间只有单个字符的url。那如果我们想提取中间个数不确定的呢？比如http://abc.jpg?我们就在.后面加个+即可；+表示大于等于1个，比如http://.+.jpg我们既可以匹配到http://a.jpg也可匹配到http://aaa.jpg等中间多个字符的url。 那么后面的?呢,这里的?多代表的是非贪婪匹配，举个例子:http://aa.jpg.jpg像这种url我们该怎么提取呢，如果按照刚才http://.+.jpg的表达式匹配出来的是http://aa.jpg.jpg整个串，但是我们只想提取到http://aa.jpg怎么办，我们就在+后面加个?代表尽可能少的匹配，就是所谓的非贪婪匹配。 最后在说一下(?&lt;=(src=\&quot;))这个意思就是我们要提取src=&quot;后面的http:xx.jpg的图片，但是不包含src=&quot;。举个🌰:如果把这个表达式去掉，我们会发现提取到的url有可能是这样https://www.enterdesk.com/bizhi/5488.html\&quot;&gt;&lt;img src=\&quot;https://up.enterdesk.com/edpic_360_360/34/3f/f4/343ff4ada1548da0a81388f86dd9d1af.jpg，很显然这不是我们想要的结果。所以说这个就是起到了相应的作用。 附上项目源码]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[春江花月夜 【作者】张若虚 【朝代】唐 译文对照 春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰；空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。不知乘月几人归，落月摇情满江树。 12345@interface Dog- (void)viewDidLoad()&#123; NSLog(@"Hello world");&#125;@end 12345class Dog&#123; public static void main(String[] args)&#123; System.out.println("Hello world"); &#125;&#125; 仅此纪念部署的第一个博客， 特别感谢:Devin_ tag { color:#999999 } author { font-size:14px }]]></content>
  </entry>
</search>
