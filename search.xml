<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序隐藏canvas的坑]]></title>
    <url>%2F2018%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9A%90%E8%97%8Fcanvas%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[需求今天收到一个需求，内容是在微信小程序点击按钮后，弹出一个动态生成的图片，并且保存在系统相册里面。在实现过程中遇到一些坑，记录一下。 Canvas动态生成图片第一步先在普通页面实现动态生成图片的功能，先不考虑隐藏等功能。代码如下:wxml: 12345&lt;canvas canvas-id=&quot;shareCanvas&quot; style=&quot;width:&#123;&#123;canvasWidth&#125;&#125;px;height:&#123;&#123;canvasWidth*1.5&#125;&#125;px&quot;&gt;&lt;/canvas&gt;``` `JS:` var canvas = wx.createCanvasContext(‘shareCanvas’) canvas.drawImage(‘../../image/share-img.png’,0,0,this.data.canvasWidth,this.data.canvasWidth * 1.5) canvas.setTextAlign(‘center’)canvas.setFillStyle(‘#ffffff’)canvas.setFontSize(12)canvas.fillText(“生成的文字”, this.data.canvasWidth 0.5, this.data.canvasWidth 1.26) canvas.stroke();canvas.draw() wx.canvasToTempFilePath({ canvasId: ‘shareCanvas’, success: function(res) { wx.saveImageToPhotosAlbum({ filePath: res.tempFilePath, success: function(res) { console.log(res) }, fail: function(err) { console.log(err) } }) }})12345678910以上js代码就是获取`canvas`控件，填充一张图做背景，然后生成文字。 然后`canvas`生成图片，在成功回调方法里面保存到相册里面。 以上代码在正常页面内执行没问题。### Canvas在自定义组件内 完成了第一步后，考虑到这个按钮可能在不同的页面。就单独把上面的功能封装成一个组件。 在普通页面引入组件后，报错`&quot;canvasToTempFilePath: fail canvas is empty&quot;`,查阅文档后，发现`createCanvasContext``canvasToTempFilePath``saveImageToPhotosAlbum`这三个方法需要传`this`这个参数。`JS`: var canvas = wx.createCanvasContext(‘shareCanvas’,this)…wx.canvasToTempFilePath({ canvasId: ‘shareCanvas’, success: function(res) { wx.saveImageToPhotosAlbum({ … },this) }},this)12345改成这样就可以了。### 隐藏 Canvas现在来解决隐藏`canvas`的问题。在需要的时候才会显示,类似于弹框，后面有个蒙版的样式。`wxml:` 12345这样我们控制`root`就可以控制整个组件的隐藏和显示了。那么问题来了，保存的图片都是空白的。获取不了`canvas`的内容。如果在显示情况下没问题，当`root`隐藏后就不行了。 在网上基本查到这两种解决方法： 方法一:这种方法模拟器可以，但是在真机上不行，所以这个方法放弃了。 12方法二: 这种主要是把`canvas`放到无限远的位置，并且设置页面不可滚动。因为我这个是组件，所以不一定哪个页面要用，觉得比较麻烦，放弃。 “disableScroll”: true123那么有没有更好的解决方法呢? 我们分析一下，当`root`显示的情况下`canvas`这个没问题，如果`root`先隐藏在显示,`canvas`就会出现问题了。那么我们能不能监听`root`隐藏和显示方法的事件呢？当显示完成后在去使用`canvas`呢？经过一翻搜索后，好像不能监听隐藏显示。 换个思路：不监听`root`的显示和隐藏，直接用`setTimeout`试试呢? setTimeout(function() { var canvas = wx.createCanvasContext(‘shareCanvas’,this) … wx.canvasToTempFilePath({ canvasId: ‘shareCanvas’, success: function(res) { wx.saveImageToPhotosAlbum({ … },this) } },this)},100)12345延迟0.1秒后在操作`canvas`,😆果然成功了，该死的小程序。### Canvas 第一次空白测试几次后发现第一次获取的图片还是空白的，而之后就好了。经过研究之后在`canvas.draw()`回调方法里面也是延迟0.1秒后就没问题了。 canvas.draw(false, setTimeout(function() { wx.canvasToTempFilePath({ … }, this)}, 100))1234### 完整代码`JS`: make: function () { this.setData({ show: &apos;&apos; }) var that = this; setTimeout(function () { var canvas = wx.createCanvasContext(&apos;shareCanvas&apos;, that) canvas.drawImage(&apos;../../image/share-img.png&apos;, 0, 0, that.data.canvasWidth, that.data.canvasWidth * 1.5) canvas.setTextAlign(&apos;center&apos;) canvas.setFillStyle(&apos;#ffffff&apos;) canvas.setFontSize(12) canvas.fillText(&quot;动态文字&quot;, that.data.canvasWidth * 0.5, that.data.canvasWidth * 1.26) canvas.stroke(); canvas.draw(false, setTimeout(function () { wx.canvasToTempFilePath({ canvasId: &apos;shareCanvas&apos;, success: function (res) { wx.saveImageToPhotosAlbum({ filePath: res.tempFilePath, success: function (res) { console.log(res) } }, that) } }, that) }, 100)) }, 100) } 12`wxml:` `]]></content>
  </entry>
  <entry>
    <title><![CDATA[runtime能做些什么]]></title>
    <url>%2F2018%2Fruntime%E8%83%BD%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言面试的时候面试官问：讲讲对runtime的理解，runtime能做些什么? 我基本上就是回答动态添加属性、添加方法、方法的替换……等网络罗列的一大堆。但是具体怎么做，这个嘛，我也说不出来。基于此，我特地研究了一下runtime.h这个文件，过滤了一下里面所有的方法并且了解基本功能并记录在此。 准备进入到runtime.h文件里面，发现里面有些方法标记的是OBJC_ARC_UNAVAILABLE，所以我们需要单独创建一个MRC项目，以便于尝试所有方法。 创建项目这里我们创建Command Line Tool工程即可，如图一: MRC项目创建完成后，默认是ARC模式的，这里我们修改为MRC。在TATGET-&gt; Build Settings-&gt;Objective-C Automatic Reference Counting-&gt;NO,默认为YES表示使用ARC模式，这里我们修改为NO即可。 类创建我们的测试类，创建Animal类，添加一个name属性和一个speak方法,一起看下类的构造: 方法介绍准备好了之后，来到main.m文件,导入objc/runtime.h和Animal.h头文件文件。 实例方法object_copy原型: 123OBJC_EXPORT id _Nullable object_copy(id _Nullable obj, size_t size)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:拷贝对象用的,和copy方法一样,返回一个新的对象。参数:obj被拷贝的对象，size对象的占用内存大小，从源码可知，size最小为16。注意:这个方法是OBJC_ARC_UNAVAILABLE，在ARC下不可用,而且如果参数obj为nil 或者是TaggedPointer,则直接返回obj,并不进行拷贝。 object_dispose原型: 123OBJC_EXPORT id _Nullable object_dispose(id _Nullable obj)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:销毁对象，并且释放空间。参数:obj要释放的对象。注意:在demo中,调用此方法后，对象还是能正常使用，没有查找到原因，改天研究下单列一篇文章。源码: 1234567id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 从源码中可以看到，首先判断obj是否为空，否则调用objc_destructInstance销毁对象,然后调用free()释放空间。 object_getClass原型: 123OBJC_EXPORT Class _Nullableobject_getClass(id _Nullable obj) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取对象的Class，和对象直接调用class方法基本一致,内部实现是返回obj的isa指针，对于isa指针这里不赘述。注意:如果obj传nil,则返回值为Nil object_setClass原型: 123OBJC_EXPORT Class _Nullableobject_setClass(id _Nullable obj, Class _Nonnull cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 修改一个对象的类,目的是修改一个对象的isa指针,返回值是旧的class。注意:调用此方法之后，对象的类型就会改变，所以在开发中应该谨慎使用此方法。由下图中可以看到，调用object_setClass方法后，a1由原来的Animal 变成NSObject对象，然后在向a发送消息立即崩溃。崩溃信息提示NSObject不存在setName方法。 object_isClass原型: 123OBJC_EXPORT BOOLobject_isClass(id _Nullable obj) OBJC_AVAILABLE(10.10, 8.0, 9.0, 1.0, 2.0); 描述:判断一个对象是否是类对象，注意:类也是一个对象，具体为什么，这里不会赘述。由下图可以看出，a1不是一个类，所以他不是类对象，Animal是一个类，所以返回TRUE。 object_getIvar原型: 123OBJC_EXPORT id _Nullableobject_getIvar(id _Nullable obj, Ivar _Nonnull ivar) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 获取obj的ivar的值。和这个方法功能类似的还有一个方法object_setInstanceVariable,但是这个获取的结果速度回更快一些，从object_setInstanceVariable源码中可以看出来，最终也是调用的这个方法。为了测试此方法，我们为Animal类添加一个变量age。由下图也可以看出属性和变量的区别。 object_getInstanceVariable原型: 12345OBJC_EXPORT Ivar _Nullableobject_getInstanceVariable(id _Nullable obj, const char * _Nonnull name, void * _Nullable * _Nullable outValue)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:这个方法和上个方法类似，也是获取属性或者变量的值，只不过参数和返回值不同。参数:obj被获取的对象;name变量的名称,字符串格式;outValue这个变量的值。通过源码可以看出这个方法的实现过程就是通过name获取Ivar,然后调用上述方法。所以官方注释上说此方法慢与上述方法。这里就不上图了，图和👆的一样。 object_setIvarobject_setIvarWithStrongDefault原型: 123OBJC_EXPORT voidobject_setIvar(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 1234OBJC_EXPORT voidobject_setIvarWithStrongDefault(id _Nullable obj, Ivar _Nonnull ivar, id _Nullable value) OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0); 描述:因为这两个方法基本相同,所以这里放在一块说了，这两个方法是给变量赋值，相当于a1.name=我是小狗。这两个方法的区别在于第一个会给属性用Unretained修饰，第二个会用Strong修饰，注意这个前提是这个属性没有被修饰的情况下才会起作用。比如name已经被copy修饰了，那就保持原来的样子，那么这两个方法是没有区别的。参数:obj被赋值的对象;Ivar即将赋值的变量,value被赋的值。注意:如果对象没有这个属性，是不能赋值的。 object_setInstanceVariableobject_setInstanceVariableWithStrongDefault原型: 12345OBJC_EXPORT Ivar _Nullableobject_setInstanceVariable(id _Nullable obj, const char * _Nonnull name, void * _Nullable value)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 123456OBJC_EXPORT Ivar _Nullableobject_setInstanceVariableWithStrongDefault(id _Nullable obj, const char * _Nonnull name, void * _Nullable value)OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0, 2.0)OBJC_ARC_UNAVAILABLE; 描述:这两个方法和上面两个方法基本相同,只是参数和返回值不同，从源码可以看出内部调用的也是上述两个方法而已。直接演示使用方法： 获得类定义objc_getClassobjc_lookUpClass原型: 123OBJC_EXPORT Class _Nullableobjc_getClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 123OBJC_EXPORT Class _Nullableobjc_lookUpClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:上面两个方法都是通过字符串获取一个Class,并且整个类是在工程里面存在的，否则会返回nil。注释上说objc_getClass方法会在第一次没有找到Class的情况下会再次查询一变并且执行回调。从源码上面看着两个方法都是执行了look_up_class(const char *aClassName, bool includeUnconnected, bool includeClassHandler)这个方法。区别在于includeClassHandler这个参数。objc_getClass传的是YES，而后者是NO。在look_up_class实现上看，旧版本的实现是按照注释上所说的一样。但是新版本的这个参数被标记为unused,基本上现在两个方法相同。 objc_getRequiredClass原型: 123OBJC_EXPORT Class _Nonnullobjc_getRequiredClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:这个方法和上面的objc_getClass方法基本一致，内部调用的就是objc_getClass这个方法，只不过在没有找到方法的情况下，会报链接失败。贴下源码: 123456Class objc_getRequiredClass(const char *aClassName)&#123; Class cls = objc_getClass(aClassName); if (!cls) _objc_fatal(&quot;link error: class &apos;%s&apos; not found.&quot;, aClassName); return cls;&#125; objc_getMetaClass原型: 123OBJC_EXPORT Class _Nonnullobjc_getMetaClass(const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:获取类的元类,这个方法和objc_getRequiredClass基本类似，也是调用了objc_getClass这个方法，只不过在没有找到Class的时候会报提示信息，不会Crash,然后会返回Nil,最终返回Class的isa指针。从图中看到控制台里面打印信息。贴下源码: 123456789101112131415Class objc_getMetaClass(const char *aClassName)&#123; Class cls; if (!aClassName) return Nil; cls = objc_getClass (aClassName); if (!cls) &#123; _objc_inform (&quot;class `%s&apos; not linked into application&quot;, aClassName); return Nil; &#125; return cls-&gt;ISA();&#125; objc_getClassList原型: 123OBJC_EXPORT int objc_getClassList(Class _Nonnull * _Nullable buffer, int bufferCount)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:获取指定的个数类列表。buffer需要传入一个Class数组，bufferCount需要传入想要的个数,返回值是类的总数。如果bufferCount传入的数比类的总数大，则最多能返回所有的类。如果bufferCount比类的总数小，则会返回这个个数的类，从下图中可以看到已经有13062个类了。注意:获取的类有可能不是NSObject的子类，所以要小心调用这些类的方法.图中实例获取10个类: objc_copyClassList原型: 123OBJC_EXPORT Class _Nonnull * _Nullableobjc_copyClassList(unsigned int * _Nullable outCount)OBJC_AVAILABLE(10.7, 3.1, 9.0, 1.0, 2.0); 描述:这个方法和上面的方法类似，只不过这个是一次性获取所有的类，outCount向外输出类的总个数。注意:这个方法返回值是Class指针，所以在使用完成后需要调用free()进行释放。 类方法class_getName原型: 123OBJC_EXPORT const char * _Nonnullclass_getName(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 获取Class的名字，返回值类型是const char *。这个在简单不过，上图已经演示了。不在赘述。 class_isMetaClass原型: 123OBJC_EXPORT BOOLclass_isMetaClass(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:判断一个Class是否是元类，返回值是bool类型。 class_getSuperclass原型: 123OBJC_EXPORT Class _Nullableclass_getSuperclass(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取Class的父类。 和OC的superclass功能一样。从下图可以看出Animal的父类是NSObject。 class_setSuperclass原型: 1234567OBJC_EXPORT Class _Nonnullclass_setSuperclass(Class _Nonnull cls, Class _Nonnull newSuper) __OSX_DEPRECATED(10.5, 10.5, &quot;not recommended&quot;) __IOS_DEPRECATED(2.0, 2.0, &quot;not recommended&quot;) __TVOS_DEPRECATED(9.0, 9.0, &quot;not recommended&quot;) __WATCHOS_DEPRECATED(1.0, 1.0, &quot;not recommended&quot;)__BRIDGEOS_DEPRECATED(2.0, 2.0, &quot;not recommended&quot;); 描述:改变某个Class的父类。一定要谨慎使用这个函数。被标记为not recommended。返回值是就的父类。看下图，当把Animal的父类改成NSString之后，把a1当做字符串操作，运行没有任何问题。但是当调用Animal原来的方法之后，就会报方法找不到。 class_getVersionclass_setVersion123OBJC_EXPORT intclass_getVersion(Class _Nullable cls)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 123OBJC_EXPORT voidclass_setVersion(Class _Nullable cls, int version)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:这两个方法比较简单，就放一块说了，其实就是设置和获取Class的版本。 直接上图: class_getInstanceSize原型: 123OBJC_EXPORT size_tclass_getInstanceSize(Class _Nullable cls) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取这个类所占用字节数。不详细讲了，网上都是讲解。 class_getInstanceVariable原型: 123OBJC_EXPORT Ivar _Nullableclass_getInstanceVariable(Class _Nullable cls, const char * _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:通过一个Class 获取指定属性。 这个和object_getInstanceVariable基本一致，返回的是同一个Ivar对象。只不过object_getInstanceVariable 会向外输出值。 class_getClassVariable原型: 123OBJC_EXPORT Ivar _Nullableclass_getClassVariable(Class _Nullable cls, const char * _Nonnull name) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 这个方法至少我认为基本上没什么用处。由字面意思看是获取类变量，OC语法也不支持这个。从源码上来看这个就是获取ISA指针的属性，图上演示的是等效的。 class_copyIvarList原型: 123OBJC_EXPORT Ivar _Nonnull * _Nullableclass_copyIvarList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:我估计这个方法我们接触的比较多，因为在利用runtime归档 、解档需要用到这个方法；这个方法主要是返回Class的所有变量，返回值是一个Ivar数组。注意:在用完Ivar数组之后，必须调用free()函数进行释放，否则会导致内存泄露。 class_getInstanceMethod原型: 123OBJC_EXPORT Method _Nullableclass_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:通过SEL获取Method,这个方法估计也很熟悉，在方法替换的的时候，就是通过这个来获取实例方法的。注意:如果方法只在.h声明，但是没有在.m里面实现的话，是找不到此方法的。这个方法会在当前Class没有找到对应的SEL的时候，会一直向父级查找, 如下图都能正确找到方法的地址。 class_getClassMethod原型: 123OBJC_EXPORT Method _Nullableclass_getClassMethod(Class _Nullable cls, SEL _Nonnull name)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 描述:获取类方法，和class_getInstanceMethod基本差不多。为了测试此方法，我们在为Animal添加一个run方法，并且在.m里面实现,此方法能正确返回。如图: class_getMethodImplementation原型: 123OBJC_EXPORT IMP _Nullableclass_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 获取方法的实现。 class_getMethodImplementation_stret原型: 1234OBJC_EXPORT IMP _Nullableclass_getMethodImplementation_stret(Class _Nullable cls, SEL _Nonnull name) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0)OBJC_ARM64_UNAVAILABLE; 描述:获取方法的转发消息的实现。 class_respondsToSelector原型： 123OBJC_EXPORT BOOLclass_respondsToSelector(Class _Nullable cls, SEL _Nonnull sel) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述: 判断一个类是否实现了某个方法。和[NSObject respondsToSelector:@selector()];方法一样。 class_copyMethodList原型: 123OBJC_EXPORT Method _Nonnull * _Nullableclass_copyMethodList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述:获取所有的Class实现的实例方法。不包括类方法，也不包括父类方法。注意:此方法会返回Method数组，在用完之后需要调用free()释放，否则会导致内存泄露。从下图可以看出，给类添加属性之后，会自动生成get set方法。 class_conformsToProtocol原型: 123OBJC_EXPORT BOOLclass_conformsToProtocol(Class _Nullable cls, Protocol * _Nullable protocol) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述：判断Class是否遵循某个协议.和[NSObject conformsToProtocol:]方法一样。 class_copyProtocolList原型: 123OBJC_EXPORT Protocol * __unsafe_unretained _Nonnull * _Nullable class_copyProtocolList(Class _Nullable cls, unsigned int * _Nullable outCount)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述：获取Class所有遵循的协议。返回值是一个OC类数组Protocol **。注意:在使用完后调用free()方法释放内存。 class_getProperty原型: 123OBJC_EXPORT objc_property_t _Nullableclass_getProperty(Class _Nullable cls, const char * _Nonnull name)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述：通过name获取指定的属性。 仅仅包含@property标记的属性。不包含变量和父级属性,如下图崩溃原因是没用获取到age属性，调用相应的方法直接报错。 class_copyPropertyList原型: 123OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 描述：获取所有的属性，仅仅包含@property标记的属性。不包含变量和父级属性。注意:该方法返回值是一个objc_property_t 数组，并且在使用完后一定要调用free()方法释放内存，否则会导致内存泄露。 class_getIvarLayout原型: 123OBJC_EXPORT const uint8_t * _Nullableclass_getIvarLayout(Class _Nullable cls)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_getWeakIvarLayout原型: 123OBJC_EXPORT const uint8_t * _Nullableclass_getWeakIvarLayout(Class _Nullable cls)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_addMethod原型: 1234OBJC_EXPORT BOOLclass_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_replaceMethod原型: 1234OBJC_EXPORT IMP _Nullableclass_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_addIvar原型: 1234OBJC_EXPORT BOOLclass_addIvar(Class _Nullable cls, const char * _Nonnull name, size_t size, uint8_t alignment, const char * _Nullable types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_addProtocol原型: 123OBJC_EXPORT BOOLclass_addProtocol(Class _Nullable cls, Protocol * _Nonnull protocol) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_addProperty原型: 12345OBJC_EXPORT BOOLclass_addProperty(Class _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0); class_replaceProperty原型: 12345OBJC_EXPORT voidclass_replaceProperty(Class _Nullable cls, const char * _Nonnull name, const objc_property_attribute_t * _Nullable attributes, unsigned int attributeCount)OBJC_AVAILABLE(10.7, 4.3, 9.0, 1.0, 2.0); class_setIvarLayout原型: 123OBJC_EXPORT voidclass_setIvarLayout(Class _Nullable cls, const uint8_t * _Nullable layout)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); class_setWeakIvarLayout原型: 123OBJC_EXPORT voidclass_setWeakIvarLayout(Class _Nullable cls, const uint8_t * _Nullable layout)OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); objc_getFutureClass原型: 1234OBJC_EXPORT Class _Nonnullobjc_getFutureClass(const char * _Nonnull name) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0)OBJC_ARC_UNAVAILABLE; 实例化类class_createInstanceobjc_constructInstanceobjc_destructInstance添加类objc_allocateClassPairobjc_registerClassPairobjc_duplicateClassobjc_disposeClassPair方法method_getNamemethod_getImplementationmethod_getTypeEncodingmethod_getNumberOfArgumentsmethod_copyReturnTypemethod_copyArgumentTypemethod_getReturnTypemethod_getArgumentTypemethod_getDescriptionmethod_setImplementationmethod_exchangeImplementations实例变量ivar_getNameivar_getTypeEncodingivar_getOffset属性property_getNameproperty_getAttributesproperty_copyAttributeListproperty_copyAttributeValue协议objc_getProtocolobjc_copyProtocolListprotocol_conformsToProtocolprotocol_isEqualprotocol_getNameprotocol_getMethodDescriptionprotocol_copyMethodDescriptionListprotocol_getPropertyprotocol_copyPropertyListprotocol_copyPropertyList2protocol_copyProtocolListobjc_allocateProtocolobjc_registerProtocolprotocol_addMethodDescriptionprotocol_addProtocolprotocol_addProperty库objc_copyImageNamesclass_getImageNameobjc_copyClassNamesForImage选择器sel_getNamesel_registerNamesel_isEqualobjc_enumerationMutationobjc_setEnumerationMutationHandlerobjc_setForwardHandlerimp_implementationWithBlockimp_getBlockimp_removeBlockobjc_loadWeakobjc_storeWeak添加变量objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects]]></content>
  </entry>
  <entry>
    <title><![CDATA[.NetPK系统]]></title>
    <url>%2F2018%2F%E4%BC%98%E6%B3%8C%E4%B9%90PK%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[项目简介前些天公司接到一个在线PK的项目，用户需求是模仿微信小程序的《头脑王者》，不过会比这个简单些，题目是公司内部拟定好的，都是关于疾病之类的比如糖尿病、心脏病等等。还有就是项目是在微信公众号上跳转到的WEB页面，庆幸的是微信公众号开发我还是比较熟悉的，可怕的是用户强烈要求用C#语言，运行环境是Windows Server 2008 、IIS8、SQL Server 2008，用户数量在500左右。好吧我承认我没有做过C#开发，不过还能回忆起遥远的过去在学校学的一点点可能有用的知识，对我来说这是一个挑战，不过好在用户数量很少，这是他们公司内部员工用的软件，真实哔了狗了。 需求分析根据和客户的对接内容，大概是想要一个前端程序和一个后台管理系统。基本功能为用户通过关注微信公众号之后可以点击链接进入到游戏中心。其中前端主要包含以下四个模块： 王者训练场：用户平常练习的场所，每道题回答成功后会获得相应的分数。 全民PK：用户和用户之间PK的场所，里面包括实时PK和离线PK。 个人中心：可以查看自己的基本资料和得分情况。 排行榜：可以查看所有用户的排行情况以及自己的周排名和月排名。 后台主要包含以下四个模块： 题库管理：用户可以查看和编辑题库。 广告管理：所谓的广告就是用户在答题个过程中，在题目下发会显示一行文字广告。这里可以编辑广告内容。 用户管理：管理参与答题的用户和查看答题情况，并每月或者每周提取前20名进行线下奖励，所以这里需要进行按月或者按周排序。 PK管理：查看用户的PK情况以及用户在PK过程中参与答题的情况。 根据以上描述大概整理了两个对应的脑图,我是业余的请忽略美观性： 基础设计 前端：好在客户提供微信端的设计图，PSD格式的文件。我们开发者自己来切图即可，这样我们就省去了UI设计的时间，我们只是数据的搬运工。 后台：后台只有一个管理员维护，对UI要求不高，方便操作即可，我想这是大部分管理后台的通用模式。 开发环境：好吧，我只是iOS开发者，用的是MacPro我尝试用Mac版本的Visual Studio,但是官方上面好像写的是测试版本；而且Mac版本的主打.net core,对.net MVC并不友好而且对数据库之类的操作不太方便；最主要的是IIS环境。好吧我放弃了Mac版本。what the f**k 安装VMware -&gt;Windows Server 2012-&gt;IIS8 -&gt;Microsoft Visual Studio,😓😓😓忙活了一下午甚至加了个班，创建个.net MVC可以跑起来了。(我没用.net core)的原因主要是客户那边有技术团队在维护微信公众号，用的是.net MVC,我避免有坑，所有我也照旧了。 数据库：此处省略。 开发一名同事加入了，他负责微信端所有的页面，其余的后台和接口我来负责😭😭😭。啪啪啪…啪啪啪…啪啪啪…撞击声伴随着做出东西的快感…此处省略500字…一遍又一遍的调试，终于功夫不负有心人，两个周的时间搞定，内部测试通过用户测试没啥问题，接下来就是调整需求了😆😆😆😆（此处不讲了,甲方还是那个甲方） 接下来上效果: 后台：.Net 前端: 难点我认为此项目的难点在于PK模块，经过多方查阅资料，也没有找出个所以然来。于是我采取了WebSocket + Timer的方式，这样对于500多用户的应该没什么问题。WebSocket 负责保持和用户通讯，Timer每秒负责循环处理用户的数据。 1.首先创建enum PKUserStatus 用来表示用户的几种状态,这个枚举表示从用户链接成功到PK结束的所有状态: 12345678910111213141516171819202122232425262728293031323334353637383940414243public enum PKUserStatus &#123; /** * 等待匹配 */ WAIT_PAIR = 0, /**匹配成功，等待客户端确认 */ WAIT_PAIR_SUCCESS, /**匹配失败，可能准备关闭连接 */ WAIT_PAIR_FAILURE, /**客户端已经确认，等待服务端发题 */ WAIT_ISSUE, /**发题 */ ISSUE, /**等待客户端回答 */ WAIT_ANSWER, /**胜利 */ WIN, /**失败 */ FAIL, /**无效 */ INVALID, /**平局 */ //DRAW,&#125; 2.创建User类:基本的用户对象 123456789101112131415161718192021public class PKUser&#123; //进入系统时间 public DateTime connectTime &#123; get; set; &#125; //userId public int userId &#123; get; set; &#125; //用户当前的状态 private PKUserStatus __status &#123; get; set; &#125; //回答题目累计用时 public int answerTime &#123; get; set; &#125; //正在连接的socket public WebSocket webSocket &#123; get; set; &#125; //... 根据需要的参数或者方法 ...//&#125; 3.创建PKContext类:类似于房间的概念，每个PKContext表示一个PK场次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public class PKContext&#123; //当前PK所需要回答的题目 private List&lt;question_info_vo&gt; questions &#123; get; set; &#125; //当前正在回答的题目，回答规则是双方同时获得新题目，如果一方回答完，则会等待另一方回答结 束才会有新的试题。 private int currentIndex = 0; //仅支持2人pk,所以这里直接定义了两个user对象 public PKUser user1 &#123; get; set; &#125; public PKUser user2 &#123; get; set; &#125; //获取下一道试题，如果已经为最后一道，则返回null public question_info_vo nextQuestion() &#123; if (currentIndex &lt; questions.Count()) &#123; return questions[currentIndex++]; &#125; return null; &#125; //保存pk信息 private void insertPKInfo() &#123; //... &#125; //结算分数 public void insertUserScore() &#123; //... &#125; //用户答题 public void answers(PKUser user, Dictionary&lt;string, object&gt; options) &#123; //... &#125; public int score(PKUserStatus staus) &#123; return 0; &#125; //... 其他方法 ...//&#125; 4.接下来的流程控制在控制器实现即可: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public class WSChatController : ApiController&#123; /** * 用户连接池，等待匹配的用户，没有匹配的用户在这里暂存， * 最大存活60s，过期后服务器即断开此用户的链接 */ private static List&lt;PKUser&gt; USER_POOL = new List&lt;PKUser&gt;(); /** * 用户pk池，正在进行的pk保存在这里， * pk结束后需要移除 */ private static List&lt;PKContext&gt; PK_POOL = new List&lt;PKContext&gt;(); /** * 计时器,每隔1s中会轮询各个状态的用户，同时会向用户发送响应的数据 * 弊端在于定时可能会不太精确，或者在回调函数里面操作耗时的动作会影响业务流程， * 不过对于本系统绰绰有余了 */ private static Timer timer = new Timer(new TimerCallback(timerCallback), null, 1000, 1000); public HttpResponseMessage Get() &#123; if (HttpContext.Current.IsWebSocketRequest) &#123; HttpContext.Current.AcceptWebSocketRequest(ProcessWSChat); &#125; return new HttpResponseMessage(HttpStatusCode.SwitchingProtocols); &#125; private async Task ProcessWSChat(AspNetWebSocketContext arg) &#123; WebSocket socket = arg.WebSocket; int userId = int.Parse(arg.QueryString[&quot;user&quot;].ToString()); //... 此处需要判断userId的有效性，忽略 ...// try &#123; //新连接，添加到连接池里 USER_POOL.Add(new PKUser(/*构造函数*/)); while (true) &#123; if (socket.State == WebSocketState.Open) &#123; ArraySegment&lt;byte&gt; buffer = new ArraySegment&lt;byte&gt;(new Byte[2048]); WebSocketReceiveResult result = await socket.ReceiveAsync(buffer, CancellationToken.None); //服务端收到客户端消息后，会继续往下走 try &#123; if (socket.State != WebSocketState.Open) &#123; //判断客户端的状态是否不是链接状态，否则会走断开用户的方法 offline(userId); break; &#125; string userMsg = Encoding.UTF8.GetString(buffer.Array, 0, result.Count); Dictionary&lt;string, object&gt; json = new JavaScriptSerializer().Deserialize&lt;Dictionary&lt;string, object&gt;&gt;(userMsg); //此处会收集到客户端的json数据， //... 根据数据执行相应的操作 ...// &#125; catch (Exception e) &#123; &#125; &#125; else &#123; //如果用户不是链接状态，执行断开链接方法 offline(userId); break; &#125; //让cpu休息100毫秒,对cpu来说100毫秒已经是很长时间了 Thread.Sleep(100); &#125; &#125; catch (Exception e) &#123; offline(userId); &#125; &#125; /** * 定时器回调函数 */ private static void timerCallback(Object obj) &#123; Dictionary&lt;string, object&gt; msg_dic = new Dictionary&lt;string, object&gt;(); string time = timestamp(); List&lt;PKUser&gt; removeUser = new List&lt;PKUser&gt;(); /** * 处理没有匹配的User */ for (int i = 0; i &lt; USER_POOL.Count(); i++) &#123; //在此处遍历等待匹配的User,可以按照规则进行user匹配， //或者移除超时的user,过程忽略 //还可以在这里给客户端发送自定义心跳包 &#125; /** * 处理匹配成功的User */ foreach (PKContext context in PK_POOL) &#123; if (context.user1.status == PKUserStatus.WAIT_PAIR_SUCCESS) //在此处判断正在pk的用户状态，然后执行相应的业务流程即可,过程忽略 &#125; &#125; /** * 用户掉线 */ private static void offline(int userId) &#123; //用户断线, //需要清空用户数据等操作，比如USER_POOL、PK_POOL &#125; /** * 服务器主动断开链接发送close */ private static ArraySegment&lt;byte&gt; closeBuffer = new ArraySegment&lt;byte&gt;(new byte[2] &#123; 0x88, 0x00 &#125;); private static void sendClose(WebSocket socket) &#123; //socket.CloseAsync(WebSocketCloseStatus.NormalClosure,&quot;websocket closed for server&quot;,CancellationToken.None); sendBuffer(socket, closeBuffer); &#125; //... 其他方法 ...//&#125; 结语写到此处基本上算是对这个系统的核心部分搞明白了（请原谅具体实现没有写出来）,至于别的接口、前端页面、数据库之类的就不叙述了，在简单不过了。最后在吐槽一下这个pk的方案真的是太low了，不过现在跑这个系统基本上没什么问题。如果用户量比较大或者要求更高的话不建议自己写pk对战系统，最好使用商业的服务引擎，比如matchvs就不错哦！]]></content>
  </entry>
  <entry>
    <title><![CDATA[KSThumbImage(一)]]></title>
    <url>%2F2018%2FKSThumbImage%2F</url>
    <content type="text"><![CDATA[我们不研究SDWebImage的源码，自己来写一个的获取视频缩略图的网络框架。]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员的讨薪之路]]></title>
    <url>%2F2018%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%AE%A8%E8%96%AA%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[私聊 ### 前言我估计作为码农来说比较悲催的是把公司干倒闭，而最悲催的是倒闭的公司还欠着工资，这可咋办呢？在这里我记录一下我自己讨要工资的艰辛之路：### 背景公司名称: 北京XXX科技有限公司公司住所: 北京市丰台区XXX(这个是虚拟地址)合同履行地：北京市朝阳区XXX（上班的地方，就是劳务合同上面写的地址）### 经过2017年12月28号，总监给我们所有人开了一个小会，会议主题就是公司马上准备解散了，大家做好心理准备，bulabula等等一大堆。最主要的问题就是12月份的工资原本应该在1月15号发，但是总监说可能得延迟，公司会给打欠条，我们当然不同意了，但是又有什么办法啊，今天的会议到此就结束了。2017年12月31号，今天是最后一天了，下完班后公司没让员工走，就是执行12月28号的会议内容，给每个员工签订离职证明，欠款借条并且还约定利息,约定1月份的工资在3月15号之前发下来（现在想想这天我就是个傻子，吃了狗屎了，事实证明今天是看见法人的最后一天）。时间一分一秒的过去了…### 劳动仲裁2018年3月15日到了，本来该是打假的好日子，我们还是没有等来该给的工资。没有办法啊，准备仲裁吧。其实我对劳动仲裁没什么概念，就是在此时恶补一些法律知识，仲裁机构之类的，还去咨询过律师。律师也建议我申请劳动仲裁。说到律师这块对于劳动仲裁的话，咨询律师是不收律师费用的。随便在网上找个律师结构，然后会有人主动约你去聊，基本上免费,但仅仅是咨询，至于代理得要收费了。对于别的经济纠纷我估计就没那么好的待遇了。因为公司的住所是在丰台区，所以我需要去丰台区的劳动仲裁委员会去申请。当然在劳动的履行地——朝阳区也可以，但是人家建议我去住所地，因为这样的话出结果会快点。在去丰台区的劳动仲裁委员会申请劳动仲裁之前我是充分的了解到需要带什么材料，因为我怕多跑冤枉路。大概了解到需要以下材料:1. 身份证原件和复印件;2. 企业信用报告;去此处打印，在上面搜索你的公司，搜出结果后打印出来资料即可;2. 申请书原件和3份复印件;3. 送达地址确认书;4. 证据材料清单+各种证据和3份复印件,在去之前我只打印了2份复印件,害得我在现场耗资60元在复印一份;查看有效的证据;5. 公司的办公地点视频资料，这个看具体情况。我公司是因为办公地点解散了，就是说没有了办公地址，所以仲裁委让我去拍不再办公的证据。我就用手机拍几个视频后刻录在光盘上补交了上去。当然如果公司还在办公，就是说仲裁委能联系上公司的话这个证据可不用提交。以上材料的模板在此处下载2018年4月4号，一切准备好之后，我直接去了丰台区劳动人事争议仲裁院（北京市丰台区南三环西路91号院宝隆大厦）提交了上述1、2、3、4资料。至于5的话，刚才说了是后补交上的。时间在流失…2018年4月10号，终于有消息了，这天有个电话打给我说你的案子已经立了，有什么事直接给我打电话就行。而且还特意重重的复述了一遍，恐怕我不知道啥意思的似的：“这次我打电话是告诉你的案子已经立了”。接下来是等待…2018年4月12号，那个仲裁员又给我打电话了，说公司法人联系不上，你需要提供办公地址的视频资料，而且是提供办公地址和住所地址的两个视频。就是上面开始说的第5号资料,-_-||你们是做什么的，这些需要我去拍吗。向势力低头，跑了两个地方拍了视频，耗资18元买了个光盘，保存在光盘上…2018年4月16号，又去了仲裁院送了光盘。又是可恶等待…2018年5月15日，这个时间有点长，中间快有一个月的时间了，仲裁员通知我准备开庭了，去领开庭通知书。心里有点激动，终于有点眉目了。当天下午就去领回来了，开庭通知书上面写了一些注意事项和开庭时间。至于这个问什么这么长，主要是因为他们联系不上公司，他们只好把这个通知书发公告了，就是在《工人日报》上面。等到公告时间到了，就相当于公司默认领取了，才开始下一步。当然如果联系上了公司的话，估计没那么长时间。2018年8月12日，按照开庭通知书上面的时间，这天早早来到仲裁院等到了9：30终于开始了，不是说9点的吗??????注意：这天一定要带上证据原件，在法庭上仲裁员会核查的。不然等到人家说你“证据都不带，你是来干嘛的”那就尴尬了。在法庭上，仲裁员、文书、我三个人，公司没人去属于缺席裁决。基本流程就是开始我讲一下经过，然后仲裁员问些基本问题，比如你是XXX吗？讲一下你的情况啦？你这个证据想证明什么呀？等等。有个问题问的相对细一些，就是那个终止劳动合同是怎么终止的？有没有具体的证据？因为我要求的赔偿上面有半个月的工资，所以这个问的比较深，我也没有实质的证据2017年12月28号那天只是口头描述的，而且在2017年12月31号那天还签了那几个协议，所以我估计这个半月的赔偿没戏了吧，文书那么只负责记录我们的谈话记录。整个过程仲裁员的语速很快，快到我需要仔细回想一下才能听到他说的什么意思😆，估计都是固定流程，总体算下来不到十分钟，所以我们很快就解决了。最后结束的时候还是那句话，回去等通知，有问题给她打电话之类。2018年8月22号,电话通知我裁决书下来了，让我去领。2018年8月23号,我带着身份证去领回来了仲裁书和一个送达回证这。他们告诉我这个送达回证可以上诉用。仲裁结果就是要求公司下发1月份的工资和这期间的利息，驳回了半个月的赔偿。公司的仲裁书又是发公告了，指定60内来领取，如果不领的话就相当于默认领取。仲裁这一步估计就这样结束了…还是等待，这效率…等了这么多天，还是安静的过去了…### 申请执行开始我去朝阳法庭申请,人家说你仲裁在丰台为啥要来朝阳啊，我说我劳务合同在朝阳。他看了看说我们快下班了，你明天再来吧，或者直接去丰台法院，朝阳的太多了排队得很长时间,才刚过4点你们就要下班了，我能说什么，。2018年10月26日,去丰台。开始我通过法院电话告诉我去丰台区人民法院丽泽法庭,我带着仲裁结果的材料兴高采烈的到这后，他们告诉我不在这里，需要去近园路立案。我无语了…反正两个地方不太远,直接去一趟吧,到了后在服务台上面他们告诉我少了一个文件——被执行人的送达回证，要去仲裁院那么去要。现在又整理一下申请执行的材料1. 身份证+复印件；2. 申请执行书一份，下载;3. 法律文书，就是那个仲裁书；4. 自己和公司的送达回证，这个再从仲裁院要；5. 如果你有公司的财产证据，可以提供；2018年10月31日，联系仲裁员要双方的送达回证。约定明天去取。2018年11月1日，领回来双方的送达回证，直接再去法院。叫号——排队——到我了——递上材料。窗口人员说：我给你说下哈，你这个还不能申请执行，你看这个公告上面写的是60天之内让公司来领裁决书，然后裁决书上面写领到裁决书后不服的话15天之内申请上诉。如果不上诉的话限7天之内付钱。这一共算下来就是60+15+7=82天，就是说从公告开始后82天才可以来申请。what the f**k。回家，我在等一分钟…稍后附图]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（二）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上次写过爬虫的初篇，我们已经能爬到基本的数据了。但是一张网页的数据是有限的，从我们上次的程序来看，能抓到的图片才不过十来张。很显然不能满足我们的需求。 接下来，我们继续完善我们的项目，来满足这个需求吧。 必备工具 联接网络的Mac, 浏览器，推荐用Google Chrome, Xcode开发工具, 用Objective-C写一个简单的爬虫(一) 的源码 必备技能建议看完 用Objective-C写一个简单的爬虫(一) ,明白一些简单的知识,虽然我写的很烂,但也不至于看这篇文章的时候一头雾水。 本篇目标深度抓取更多的数据如图: 分析在上篇中，我们给定一个url抓取完图片之后直接就结束了，那么如何不让程序结束，而继续抓取别的ur呢？总不能给SpiderOption定义一个url数组,程序的输入是有限的,这种办法解决不了问题。聪明的你一定想到了，在爬虫爬取图片的时候，不也是可以爬到这个页面的跳转页面么，如果我们在把跳转页面的图片爬下来，甚至把跳转页面里面的跳转页面爬下来，这样一直往深层次的抓取数据，就不是源源不断的图片爬到手了么？😎下面我们就开始吧！！！ 编码准备首先我们改造一下Spider类，给Spider添加几个变量:1、_finashUrl 用来存放已经爬取过的url,防止重复抓取,导致重复循环。2、_session 用来进行获取html的网络请求;在第一篇中我们直接在方法里面定义了相同的变量,这里我们把它声明成变量,防止重复创建对象.3、_urlExpression 用来匹配url的正则表达式.4、_imgExpression 用来匹配img的正则表达式.5、fetchHtmlQueue 正则匹配的队列.6、operationQueue 网络请求的队列. 定义上面变量之后并且在init方法中初始化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface Spider()&lt;NSURLSessionDataDelegate&gt;@property (nonatomic, strong) NSOperationQueue* fetchHtmlQueue;@property (nonatomic, strong) NSOperationQueue* operationQueue;@end@implementation Spider&#123; //已经抓取的url NSMutableSet&lt;NSString*&gt;* _finashUrl; NSRegularExpression* _urlExpression; NSRegularExpression* _imgExpression; NSURLSession* _session;&#125;- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; _finashUrl = [NSMutableSet set]; _imgExpression = [NSRegularExpression regularExpressionWithPattern:option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; _urlExpression = [NSRegularExpression regularExpressionWithPattern:@"https?:.+?.html" options:NSRegularExpressionCaseInsensitive error:nil]; _operationQueue = [[NSOperationQueue alloc] init]; _operationQueue.maxConcurrentOperationCount = 3; _operationQueue.name = @"com.html.loadQueue"; _fetchHtmlQueue = [[NSOperationQueue alloc] init]; _fetchHtmlQueue.maxConcurrentOperationCount = 3; _fetchHtmlQueue.name = @"com.html.fetchQueue"; NSURLSessionConfiguration* configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; configuration.timeoutIntervalForRequest = 30; _session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:_fetchHtmlQueue]; &#125; return self;&#125; 改写方法由于我们用了多线程的技术，每次加载一个url都要放到队列去，所以我们需要修改一下loadUrl方法: 12345678910111213141516- (void)loadUrl:(NSURL*)url&#123; WeakSelf; @synchronized(self)&#123; [self-&gt;_operationQueue addOperationWithBlock:^&#123; StrongSelf; NSURLSessionDataTask* task = [sSelf-&gt;_session dataTaskWithURL:url]; [task resume]; &#125;]; &#125;&#125; 上一步请求成功之后，会调用session的代理方法，所有我们需要实现session的代理方法: 1234567891011121314151617181920212223242526272829303132///MARK:- NSURLSessionDataDelegate- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler&#123; NSURLSessionResponseDisposition disposition = NSURLSessionResponseCancel; NSInteger statusCode = 0; if ([response respondsToSelector:@selector(statusCode)])&#123; statusCode = [((NSHTTPURLResponse*)response) statusCode]; &#125; if (statusCode == 200) &#123; disposition = NSURLSessionResponseAllow; &#125; completionHandler(disposition);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; if (html &amp;&amp; html.length &gt; 0) &#123; [self fetchUrlWithHtml:html]; [self fetchImgWithHtml:html]; &#125;&#125; 我们在修改一下fetchImgWithHtml方法,匹配img也要放到队列里,匹配成功后回调即可: 12345678910- (void)fetchImgWithHtml:(NSString*)html&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_imgExpression]; sSelf.option.complete ? sSelf.option.complete(strings) : nil; &#125;];&#125; 同理我们修改fetchUrlWithHtml方法,并且把需要请求的url放到_finashUrl里面,在请求之前判断一下是否请求过即可: 123456789101112131415161718- (void)fetchUrlWithHtml:(NSString*)html&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_urlExpression]; for (NSString* string in strings) &#123; NSURL* url = [NSURL URLWithString:string]; if ([sSelf-&gt;_finashUrl containsObject:string]) &#123; continue; &#125; [sSelf-&gt;_finashUrl addObject:string]; [sSelf loadUrl:url]; &#125; &#125;];&#125; 最后附上fetchStringsWithHtml方法: 12345678910111213141516- (NSArray&lt;NSString*&gt;*)fetchStringsWithHtml:(NSString*)html expression:(NSRegularExpression*)expression&#123; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; return strings;&#125; 运行接下来运行一下程序，我们能看到程序不停的抓取图片，越来越多。 可视化为了更好的浏览我们获取的图片，我们需要在控制器里面用UICollectionView展现出来，直接上代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (void)appendUrls:(NSArray&lt;NSString *&gt;*)urls&#123; if (urls.count &gt; 0) &#123; WeakSelf; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.collectionView performBatchUpdates:^&#123; NSMutableArray&lt;NSIndexPath*&gt;* idxs = [NSMutableArray array]; for (int i = 0; i &lt; urls.count; i ++) &#123; NSIndexPath* idx = [NSIndexPath indexPathForItem:weakSelf.urls.count + i inSection:0]; [idxs addObject:idx]; &#125; [weakSelf.urls addObjectsFromArray:urls]; [weakSelf.collectionView insertItemsAtIndexPaths:idxs]; &#125; completion: NULL]; &#125;); &#125;&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; self.collectionView.frame = self.view.bounds;&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return self.urls.count;&#125;- (__kindof UICollectionViewCell*)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; CollectionViewCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:CollectionViewCellID forIndexPath:indexPath]; cell.url = self.urls[indexPath.row]; return cell;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.5;&#125;- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section&#123; return 0.01;&#125;- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section&#123; return UIEdgeInsetsZero;&#125;- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewFlowLayout* layout = (UICollectionViewFlowLayout*)collectionViewLayout; CGFloat w = (CGRectGetWidth(collectionView.frame) - layout.minimumInteritemSpacing - layout.sectionInset.left - layout.sectionInset.right) / 8 - 0.5; return CGSizeMake(w, w);&#125;- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; DetailController* detail = [[DetailController alloc] init]; detail.url = self.urls[indexPath.row]; [self.navigationController pushViewController:detail animated:YES];&#125;- (UICollectionView *)collectionView&#123; if (!_collectionView) &#123; UICollectionViewFlowLayout* layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumLineSpacing = 0.5; layout.minimumInteritemSpacing = 0; layout.sectionInset = UIEdgeInsetsZero; _collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:layout]; _collectionView.delegate = self; _collectionView.dataSource = self; [_collectionView registerClass:[CollectionViewCell class] forCellWithReuseIdentifier:CollectionViewCellID]; _collectionView.backgroundColor = [UIColor whiteColor]; &#125; return _collectionView;&#125; 至此，我们就算完成了我们的目标;看到程序不停的有图片加载出来，是不是有点小兴奋呢。😄现在我们写的程序会无限循环的爬取，但是怎么能控制爬取深度呢？ 控制深度我的做法是给url创建一个分类，添加一个属性depth表示此url的深度值,初始的url深度为0,在此页面上爬取的url深度为1，这样以此类推，直到我们指定深度停止为止。 NSURL+depth.h 12345@interface NSURL (depth)@property (nonatomic, assign) NSUInteger depth;@end NSURL+depth.m 1234567891011121314151617#import "NSURL+depth.h"#import &lt;objc/runtime.h&gt;static const void * depth_key = "depth_key";@implementation NSURL (depth)@dynamic depth;- (NSUInteger)depth&#123; return [objc_getAssociatedObject(self, depth_key) unsignedIntegerValue];&#125;- (void)setDepth:(NSUInteger)depth&#123; objc_setAssociatedObject(self, depth_key, @(depth), OBJC_ASSOCIATION_ASSIGN);&#125;@end 然后在我们的 start方法里面给第一个url的深度赋值: 123456- (void)start&#123; NSURL* url = [NSURL URLWithString:self.option.website]; url.depth = 0; [self loadUrl:url];&#125; 在session回调的方法里面我们判断一下此url的深度是否需要继续爬取: 12345678910111213- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSUInteger depth = dataTask.originalRequest.URL.depth; if (html &amp;&amp; html.length &gt; 0) &#123; if (depth &lt; self.option.maxDepth) &#123; [self fetchUrlWithHtml:html depth:depth + 1]; &#125; [self fetchImgWithHtml:html]; &#125;&#125; 然后改下fetchUrlWithHtml方法，给下个url赋值深度: 12345678910111213141516171819202122232425262728- (void)fetchUrlWithHtml:(NSString*)html depth:(NSUInteger)depth&#123; WeakSelf; [self.fetchHtmlQueue addOperationWithBlock:^&#123; StrongSelf; NSArray&lt;NSString*&gt;* strings = [sSelf fetchStringsWithHtml:html expression:sSelf-&gt;_urlExpression]; for (NSString* string in strings) &#123; NSURL* url = [NSURL URLWithString:string]; if ([sSelf-&gt;_finashUrl containsObject:string]) &#123; continue; &#125; url.depth = depth; [sSelf-&gt;_finashUrl addObject:string]; [sSelf loadUrl:url]; &#125; &#125;];&#125;``` 最后忘说了一个地方,那就是`SpiderOption`,给这个类添加一个最大深度的属性,让外界来控制: ```objc /** 最大抓取深度 默认 NSUIntegerMax */@property (nonatomic, assign) NSUInteger maxDepth; ok,在控制器里面给定最大的深度,最好不要太大,运行一下吧！！！ 相关链接: 项目源码 用Objective-C写一个简单的爬虫(一)]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Objective-C写一个简单的爬虫（一）]]></title>
    <url>%2F2017%2F%E7%94%A8Objective-C%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[你是不是想写个爬虫来抓取点东西,但是你又不会Python或者别的语言，那么你就得感谢你自己能来到这里。接下来就交给你如何用Objective-C写一个爬虫。 什么？Objective-C也能写爬虫？不都是Python才可以的么？那么我告诉你基本上大部分语言都是可以写爬虫的，只是Python用来写爬虫比较方便，他有海量的三方库可以让开发者调用而已。而别的语言基本上就是靠自己苦逼的撸了。 那么用Objective-C写爬虫有什么用？靠iPhone来爬数据么？这里博主只是写个简单的爬虫而已，并不指望用此来专门抓取数据，你觉得让手机去爬数据能爬多少啊。本教程会兼容Mac软件开发，你可以用此技术开发mac爬虫工具。 废话少说，让我们来开始吧！ 必备工具 链接网络的Mac, 浏览器，推荐用Google Chrome Xcode开发工具 必备技能 熟悉Objective-C 能阅读HTML,能认识基本的标签即可 正则表达式,大概浏览一下就行,这里在遇到的时候博主会简单介绍一下 本篇目标 抓取回车桌面上的图片 附图: 分析网页用浏览器打开回车桌面,并且按下 option + command + i打开开发者工具。如图: 确保右上方是选中的Elements选项，下面HTML就是网页的源代码。鼠标在HTML上面移动的时候左侧页面会有相应的模块提示，我们以次点开标签，就能找到想要的图片地址: 如图: 粘一段代码: 123456&lt;img a_width="576" a_height="360" src="https://up.enterdesk.com/edpic_360_360/cf/e1/8f/cfe18f5a7e0a42355784bb992f313853.jpg" alt="清明节气" title="清明节气" style="height: 185px; width: 296px;"&gt; 上段代码中src就是网页中的图片地址，我们接下来就是把这个src的值提取出来。 编码上面我们分析了网页源码，接下来我们已经知道了大致流程： 获取网页源码 正则提取url 好! 让我们来创建一个Objective-C项目，这里我们主要是来介绍如何写爬虫，至于Objective-C项目自己创建即可。 初始化博主这里在主控制器上面添加一个UITextView，背景色为黑色；Tint 颜色为绿色，(这样的颜色看起来比较高大上一点)；不可编辑；打开超连接功能；并且连接到所在的控制器。如图: 创建工具类创建Spider类和SpiderOption类。Spider是爬虫工具类;SpiderOption是参数类，在爬数据过程中所需要的参数都由SpiderOption传递给Spider SpiderOption.h 12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;typedef void(^SpiderCompleteHander)(NSString* url);@interface SpiderOption : NSObject/** 目标网站 */@property (nonatomic, copy) NSString* website;/** 抓取数据正则表达式 */@property (nonatomic, copy) NSString* pattern;/** Url抓取完成回调 */@property (nonatomic, copy) SpiderCompleteHander progress;@end Spider.h 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;#import "SpiderOption.h"@interface Spider : NSObject/** 参数类 */@property (nonatomic, strong, readonly) SpiderOption* option;/** 初始化方法 @param option 参数类 @return self */- (instancetype)initWithOption:(SpiderOption*)option;/** 开始抓取 */- (void)start;@end Spider.m 1234567891011121314151617#import "Spider.h"@implementation Spider- (instancetype)initWithOption:(SpiderOption *)option&#123; self = [super init]; if (self) &#123; _option = option; &#125; return self;&#125;- (void)start&#123;&#125;@end 测试工具类经过第二步之后，初步的爬虫工具就可以使用了，下面我们在ViewController.m里面调用我们的爬虫工具。 ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142#import "ViewController.h"#import "Spider.h"@interface ViewController ()@property (weak, nonatomic) IBOutlet UITextView *textView;@property (strong, nonatomic) Spider *spider;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个参数类 SpiderOption* option = [[SpiderOption alloc] init]; //准备目标网址 option.website = @"https://www.enterdesk.com"; //处理回调，当成功抓取一个内容之后，我们就把他拼接到textView的底部 option.complete = ^(NSString *url) &#123; [self showLogs:url]; &#125;; //初始化爬虫类 self.spider = [[Spider alloc] initWithOption:option]; //开始抓取 [self.spider start];&#125;- (void)showLogs:(NSString*)log&#123; //把Log内容拼接到textView最下面，并且滚动到最下面 if (log.length &gt; 0) &#123; [self.textView insertText:[NSString stringWithFormat:@"%@\n\n",log]]; [self.textView scrollRangeToVisible:NSMakeRange(self.textView.text.length, 0)]; &#125;&#125;@end 现在来运行一下我们的项目，虽然不会报错，但是并没有开始爬什么数据，接下让我们来完善我们的Spider工具类。 完善工具类在我们的Spider.m里面添加一个方法，来获取网页的HTML源码： 12345678910111213141516171819- (void)loadUrl:(NSString*)urlString&#123; WeakSelf; urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL* url = [NSURL URLWithString:urlString]; NSURLSessionConfiguration* configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession* session = [NSURLSession sessionWithConfiguration:configuration]; NSURLSessionDataTask* task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@"%@",html); &#125; &#125;]; [task resume];&#125; 接下来在我们的start方法调用上述方法: 123- (void)start&#123; [self loadUrl:self.option.website];&#125; 让我们在运行一次项目，如果网络没有问题的话，我们就能看到控制器上面输出的HTML源码,尽管我们的textView还是黑黑的一片。如下图: 正则匹配我们再次给Spider.m添加一个方法,这个方法主要就是从HTML里面提取出我们想要的内容，比如我们的图片,然后回调给控制器: 123456789101112131415161718192021- (void)matchesStringInHtml:(NSString*)html&#123; WeakSelf; NSRegularExpression* expression = [NSRegularExpression regularExpressionWithPattern:self.option.pattern options:NSRegularExpressionCaseInsensitive error:nil]; NSArray&lt;NSTextCheckingResult*&gt;* results = [expression matchesInString:html options:NSMatchingReportCompletion range:NSMakeRange(0, html.length)]; NSMutableArray&lt;NSString*&gt;* strings = [NSMutableArray arrayWithCapacity:results.count]; for (NSTextCheckingResult* result in results) &#123; NSString* sub = [html substringWithRange:result.range]; [strings addObject:sub]; &#125; weakSelf.option.progress ? weakSelf.option.progress(strings) : nil;&#125; 方法写好了，我们需要在loadUrl的completionHandler调用一下. 123456789 ··· NSString* html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; if (!error &amp;&amp; html.length &gt; 0) &#123; [sSelf fetchImgWithHtml:html]; &#125;else&#123; NSLog(@"加载出错:%@",error); &#125; ··· 还需要给SpiderOption的pattern赋值，那我们在ViewController.m里面添加以下正则即可： 123456...option.website = @"https://www.enterdesk.com";option.pattern = @"(?&lt;=(src=\"))https?://.+?.(jpg|png)";... 最后，让我们运行以下看效果吧,是不是很简单呀！！！ 备注我们来解释一下正则(?&lt;=(src=\&quot;))https?://.+?.(jpg|png)表达式的含义: HTML中的图片地址可能类似于http://aaa.jpg、又或者是以https开头的https://aaa.jpg,那我们就用https?://aaa.jpg即可匹配http也可匹配https。?在这里表示前一个字符s有0个或者1个。 或许网页中的图片不仅仅是.jpg又或者是.png、.gif等等，我们用或|提取我们想要的格式图片。比如.(jpg|png)就是我们想取jpg或者是png的图片,如果你也想提取.gif的图片，可以这样写.(jpg|png|gif)即可。 我们再说说中间的.+?,.代表单个字符，比如正则表达式这样写http://..jpg我们只能提取http://a.jpg这中间只有单个字符的url。那如果我们想提取中间个数不确定的呢？比如http://abc.jpg?我们就在.后面加个+即可；+表示大于等于1个，比如http://.+.jpg我们既可以匹配到http://a.jpg也可匹配到http://aaa.jpg等中间多个字符的url。 那么后面的?呢,这里的?多代表的是非贪婪匹配，举个例子:http://aa.jpg.jpg像这种url我们该怎么提取呢，如果按照刚才http://.+.jpg的表达式匹配出来的是http://aa.jpg.jpg整个串，但是我们只想提取到http://aa.jpg怎么办，我们就在+后面加个?代表尽可能少的匹配，就是所谓的非贪婪匹配。 最后在说一下(?&lt;=(src=\&quot;))这个意思就是我们要提取src=&quot;后面的http:xx.jpg的图片，但是不包含src=&quot;。举个🌰:如果把这个表达式去掉，我们会发现提取到的url有可能是这样https://www.enterdesk.com/bizhi/5488.html\&quot;&gt;&lt;img src=\&quot;https://up.enterdesk.com/edpic_360_360/34/3f/f4/343ff4ada1548da0a81388f86dd9d1af.jpg，很显然这不是我们想要的结果。所以说这个就是起到了相应的作用。 相关链接: 项目源码 用Objective-C写一个简单的爬虫(二)]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[春江花月夜 【作者】张若虚 【朝代】唐 译文对照 春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明！ 江流宛转绕芳甸，月照花林皆似霰；空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。不知江月待何人，但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子？何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。不知乘月几人归，落月摇情满江树。 12345@interface Dog- (void)viewDidLoad()&#123; NSLog(@"Hello world");&#125;@end 12345class Dog&#123; public static void main(String[] args)&#123; System.out.println("Hello world"); &#125;&#125; 仅此纪念部署的第一个博客， 特别感谢:Devin_ tag { color:#999999 } author { font-size:14px }]]></content>
  </entry>
</search>
